
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kevensen/gollama-chat/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/kevensen/gollama-chat/internal/configuration/configuration.go (18.3%)</option>
				
				<option value="file2">github.com/kevensen/gollama-chat/internal/configuration/models/models.go (0.0%)</option>
				
				<option value="file3">github.com/kevensen/gollama-chat/internal/rag/service.go (2.6%)</option>
				
				<option value="file4">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/chat.go (0.0%)</option>
				
				<option value="file5">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/input/input.go (0.0%)</option>
				
				<option value="file6">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/message_cache.go (0.0%)</option>
				
				<option value="file7">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/messages.go (0.0%)</option>
				
				<option value="file8">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/model_context.go (0.0%)</option>
				
				<option value="file9">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/styles.go (0.0%)</option>
				
				<option value="file10">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/system_prompt.go (0.0%)</option>
				
				<option value="file11">github.com/kevensen/gollama-chat/internal/tui/tabs/chat/token_counts.go (50.0%)</option>
				
				<option value="file12">github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/configuration.go (0.0%)</option>
				
				<option value="file13">github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/models/models.go (0.0%)</option>
				
				<option value="file14">github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/utils/connection/connection.go (0.0%)</option>
				
				<option value="file15">github.com/kevensen/gollama-chat/internal/tui/tabs/rag/collections_service.go (0.0%)</option>
				
				<option value="file16">github.com/kevensen/gollama-chat/internal/tui/tabs/rag/rag.go (0.0%)</option>
				
				<option value="file17">github.com/kevensen/gollama-chat/internal/tui/tui/tui.go (0.0%)</option>
				
				<option value="file18">github.com/kevensen/gollama-chat/internal/tui/util/util.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        tea "github.com/charmbracelet/bubbletea"

        "github.com/kevensen/gollama-chat/internal/configuration"
        "github.com/kevensen/gollama-chat/internal/tui/tui"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        // Load configuration
        config, err := configuration.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Create TUI model
        <span class="cov0" title="0">model := tui.NewModel(ctx, config)

        // Create Bubble Tea program with balanced performance optimizations
        program := tea.NewProgram(
                model,
                tea.WithAltScreen(),
                tea.WithMouseCellMotion(),
                tea.WithFPS(60),            // Balanced FPS - responsive but not excessive
                tea.WithInputTTY(),         // Use TTY input for better responsiveness
                tea.WithoutSignalHandler(), // Disable signal handling for less overhead
        )

        // Run the program
        if _, err := program.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error running program: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package configuration

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
)

// Config represents the application configuration
type Config struct {
        ChatModel           string          `json:"chatModel"`
        EmbeddingModel      string          `json:"embeddingModel"`
        RAGEnabled          bool            `json:"ragEnabled"`
        OllamaURL           string          `json:"ollamaURL"`
        ChromaDBURL         string          `json:"chromaDBURL"`
        ChromaDBDistance    float64         `json:"chromaDBDistance"`
        MaxDocuments        int             `json:"maxDocuments"`
        DarkMode            bool            `json:"darkMode"`
        SelectedCollections map[string]bool `json:"selectedCollections"`
        DefaultSystemPrompt string          `json:"defaultSystemPrompt"`
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                ChatModel:           "llama3.3:latest",
                EmbeddingModel:      "embeddinggemma:latest",
                RAGEnabled:          true,
                OllamaURL:           "http://localhost:11434",
                ChromaDBURL:         "http://localhost:8000",
                ChromaDBDistance:    1.0, // Updated for cosine similarity (0-2 range)
                MaxDocuments:        5,
                DarkMode:            false,
                SelectedCollections: make(map[string]bool),
                DefaultSystemPrompt: "You are a helpful Q&amp;A bot. Your purpose is to provide direct, accurate answers to user questions. When providing lists of items (such as countries, capitals, features, etc.), format your response using proper numbered or bulleted lists. Be consistent in your formatting. If you don't know the answer, state that you are unable to provide a response.",
        }
}</span>

// getConfigDir returns the appropriate config directory based on OS
func getConfigDir() (string, error) <span class="cov0" title="0">{
        var configDir string

        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                configDir = os.Getenv("APPDATA")
                if configDir == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("APPDATA environment variable not set")
                }</span>
        default:<span class="cov0" title="0"> // Linux, macOS, and other Unix-like systems
                configDir = os.Getenv("XDG_CONFIG_HOME")
                if configDir == "" </span><span class="cov0" title="0">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to get user home directory: %w", err)
                        }</span>
                        <span class="cov0" title="0">configDir = filepath.Join(homeDir, ".config")</span>
                }
        }

        <span class="cov0" title="0">return filepath.Join(configDir, "gollama"), nil</span>
}

// getConfigPath returns the full path to the configuration file
func getConfigPath() (string, error) <span class="cov0" title="0">{
        configDir, err := getConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return filepath.Join(configDir, "settings.json"), nil</span>
}

// Load reads the configuration from the settings file
// If the file doesn't exist, it returns the default configuration
func Load() (*Config, error) <span class="cov0" title="0">{
        configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get config path: %w", err)
        }</span>

        // If config file doesn't exist, return default config
        <span class="cov0" title="0">if _, err := os.Stat(configPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return DefaultConfig(), nil
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := json.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Apply default values for any missing fields (needed for backward compatibility)
        <span class="cov0" title="0">applyDefaultsIfMissing(&amp;config)

        return &amp;config, nil</span>
}

// applyDefaultsIfMissing sets default values for any config fields that might be missing
// This ensures backward compatibility when new fields are added
func applyDefaultsIfMissing(c *Config) <span class="cov0" title="0">{
        defaultConfig := DefaultConfig()

        // Check for empty DefaultSystemPrompt and apply default if needed
        if c.DefaultSystemPrompt == "" </span><span class="cov0" title="0">{
                c.DefaultSystemPrompt = defaultConfig.DefaultSystemPrompt
        }</span>

        // Add checks for any future fields here
}

// Save writes the configuration to the settings file
func (c *Config) Save() error <span class="cov0" title="0">{
        configDir, err := getConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get config directory: %w", err)
        }</span>

        // Create config directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">configPath, err := getConfigPath()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get config path: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.OllamaURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("ollamaURL cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.ChatModel == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("chatModel cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.EmbeddingModel == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("embeddingModel cannot be empty")
        }</span>
        <span class="cov8" title="1">if c.ChromaDBURL == "" &amp;&amp; c.RAGEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("chromaDBURL cannot be empty when RAG is enabled")
        }</span>
        <span class="cov8" title="1">if c.ChromaDBDistance &lt; 0 || c.ChromaDBDistance &gt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("chromaDBDistance must be between 0 and 2 (cosine similarity range)")
        }</span>
        <span class="cov8" title="1">if c.MaxDocuments &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("maxDocuments must be greater than 0")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// OllamaModel represents a model from the Ollama API
type OllamaModel struct {
        Name     string `json:"name"`
        Size     int64  `json:"size"`
        Modified string `json:"modified"`
}

// OllamaModelsResponse represents the response from /api/tags
type OllamaModelsResponse struct {
        Models []OllamaModel `json:"models"`
}

// LoadStatus represents the status of loading models
type LoadStatus int

const (
        LoadStatusIdle LoadStatus = iota
        LoadStatusLoading
        LoadStatusLoaded
        LoadStatusError
)

// ModelsLoadedMsg represents the result of loading models
type ModelsLoadedMsg struct {
        Models []OllamaModel
        Error  error
}

// ModelSelectedMsg represents a model selection
type ModelSelectedMsg struct {
        ModelName string
}

// Model represents the model selection panel
type Model struct {
        ollamaURL     string
        models        []OllamaModel
        selectedIndex int
        loadStatus    LoadStatus
        errorMessage  string
        width         int
        height        int
        visible       bool
        cursor        int
        scrollOffset  int
}

// NewModel creates a new model selection model
func NewModel(ollamaURL string) Model <span class="cov0" title="0">{
        return Model{
                ollamaURL:     ollamaURL,
                models:        []OllamaModel{},
                selectedIndex: 0,
                loadStatus:    LoadStatusIdle,
                width:         40,
                height:        15,
                visible:       false,
                cursor:        0,
                scrollOffset:  0,
        }
}</span>

// SetVisible sets the visibility of the model panel
func (m Model) SetVisible(visible bool) Model <span class="cov0" title="0">{
        m.visible = visible
        if visible &amp;&amp; m.loadStatus == LoadStatusIdle </span><span class="cov0" title="0">{
                m.loadStatus = LoadStatusLoading
        }</span>
        <span class="cov0" title="0">return m</span>
}

// SetSize sets the dimensions of the model panel
func (m Model) SetSize(width, height int) Model <span class="cov0" title="0">{
        m.width = width
        m.height = height
        return m
}</span>

// SetOllamaURL updates the Ollama URL and resets the model state
func (m Model) SetOllamaURL(url string) Model <span class="cov0" title="0">{
        m.ollamaURL = url
        m.loadStatus = LoadStatusIdle
        m.models = []OllamaModel{}
        m.errorMessage = ""
        m.selectedIndex = 0
        m.cursor = 0
        m.scrollOffset = 0
        return m
}</span>

// Init initializes the model selection panel
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        if m.visible &amp;&amp; m.loadStatus == LoadStatusLoading </span><span class="cov0" title="0">{
                return m.loadModels()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update handles messages and updates the model selection panel
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case ModelsLoadedMsg:<span class="cov0" title="0">
                if msg.Error != nil </span><span class="cov0" title="0">{
                        m.loadStatus = LoadStatusError
                        m.errorMessage = fmt.Sprintf("Failed to load models: %s", msg.Error.Error())
                }</span> else<span class="cov0" title="0"> {
                        m.loadStatus = LoadStatusLoaded
                        m.models = msg.Models
                        m.errorMessage = ""
                }</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                if !m.visible </span><span class="cov0" title="0">{
                        return m, nil
                }</span>

                <span class="cov0" title="0">switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                                if m.cursor &lt; m.scrollOffset </span><span class="cov0" title="0">{
                                        m.scrollOffset = m.cursor
                                }</span>
                        }

                case "down", "j":<span class="cov0" title="0">
                        if m.cursor &lt; len(m.models)-1 </span><span class="cov0" title="0">{
                                m.cursor++
                                maxVisibleItems := m.height - 4 // Account for border and title
                                if m.cursor &gt;= m.scrollOffset+maxVisibleItems </span><span class="cov0" title="0">{
                                        m.scrollOffset = m.cursor - maxVisibleItems + 1
                                }</span>
                        }

                case "enter":<span class="cov0" title="0">
                        if m.loadStatus == LoadStatusLoaded &amp;&amp; len(m.models) &gt; 0 &amp;&amp; m.cursor &lt; len(m.models) </span><span class="cov0" title="0">{
                                selectedModel := m.models[m.cursor]
                                return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        return ModelSelectedMsg{ModelName: selectedModel.Name}
                                }</span>
                        }

                case "r":<span class="cov0" title="0">
                        // Refresh models
                        m.loadStatus = LoadStatusLoading
                        m.errorMessage = ""
                        return m, m.loadModels()</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the model selection panel
func (m Model) View() string <span class="cov0" title="0">{
        if !m.visible </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var content []string

        // Title
        titleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("12")).
                Bold(true).
                Align(lipgloss.Center)

        content = append(content, titleStyle.Render("Available Models"))

        // Content based on load status
        switch m.loadStatus </span>{
        case LoadStatusLoading:<span class="cov0" title="0">
                loadingStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("11")).
                        Italic(true)
                content = append(content, "", loadingStyle.Render("Loading models..."))</span>

        case LoadStatusError:<span class="cov0" title="0">
                errorStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("9")).
                        Bold(true)
                content = append(content, "", errorStyle.Render(m.errorMessage))
                content = append(content, "")
                helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                content = append(content, helpStyle.Render("Press 'r' to retry"))</span>

        case LoadStatusLoaded:<span class="cov0" title="0">
                if len(m.models) == 0 </span><span class="cov0" title="0">{
                        noModelsStyle := lipgloss.NewStyle().
                                Foreground(lipgloss.Color("240")).
                                Italic(true)
                        content = append(content, "", noModelsStyle.Render("No models available"))
                }</span> else<span class="cov0" title="0"> {
                        content = append(content, "")
                        content = append(content, m.renderModelList()...)
                        content = append(content, "")
                        helpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                        content = append(content, helpStyle.Render("↑/↓: Navigate • Enter: Select • r: Refresh"))
                }</span>

        default:<span class="cov0" title="0">
                // Idle state
                idleStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Italic(true)
                content = append(content, "", idleStyle.Render("Select a model field to view models"))</span>
        }

        // Join content and apply border
        <span class="cov0" title="0">contentStr := strings.Join(content, "\n")

        panelStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("62")).
                Padding(0, 1).
                Width(m.width).
                Height(m.height)

        return panelStyle.Render(contentStr)</span>
}

// renderModelList renders the scrollable list of models
func (m Model) renderModelList() []string <span class="cov0" title="0">{
        var lines []string
        maxVisibleItems := m.height - 4 // Account for border, title, and help text

        start := m.scrollOffset
        end := start + maxVisibleItems
        if end &gt; len(m.models) </span><span class="cov0" title="0">{
                end = len(m.models)
        }</span>

        <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                model := m.models[i]
                line := m.formatModelLine(model, i == m.cursor)
                lines = append(lines, line)
        }</span>

        // Add scroll indicators
        <span class="cov0" title="0">if m.scrollOffset &gt; 0 </span><span class="cov0" title="0">{
                scrollUpStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                lines = append([]string{scrollUpStyle.Render("↑ More above")}, lines...)
        }</span>

        <span class="cov0" title="0">if end &lt; len(m.models) </span><span class="cov0" title="0">{
                scrollDownStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
                lines = append(lines, scrollDownStyle.Render("↓ More below"))
        }</span>

        <span class="cov0" title="0">return lines</span>
}

// formatModelLine formats a single model line
func (m Model) formatModelLine(model OllamaModel, isSelected bool) string <span class="cov0" title="0">{
        var modelStyle lipgloss.Style

        if isSelected </span><span class="cov0" title="0">{
                modelStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(lipgloss.Color("62")).
                        Bold(true)
        }</span> else<span class="cov0" title="0"> {
                modelStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15"))
        }</span>

        // Format the model name, truncate if too long
        <span class="cov0" title="0">maxWidth := m.width - 6 // Account for padding and potential selection indicator
        modelName := model.Name
        if len(modelName) &gt; maxWidth </span><span class="cov0" title="0">{
                modelName = modelName[:maxWidth-3] + "..."
        }</span>

        <span class="cov0" title="0">prefix := "  "
        if isSelected </span><span class="cov0" title="0">{
                prefix = "▶ "
        }</span>

        <span class="cov0" title="0">return modelStyle.Render(prefix + modelName)</span>
}

// loadModels loads models from the Ollama API
func (m Model) loadModels() tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                client := &amp;http.Client{Timeout: 10 * time.Second}
                resp, err := client.Get(m.ollamaURL + "/api/tags")
                if err != nil </span><span class="cov0" title="0">{
                        return ModelsLoadedMsg{
                                Models: nil,
                                Error:  err,
                        }
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        return ModelsLoadedMsg{
                                Models: nil,
                                Error:  fmt.Errorf("HTTP %d", resp.StatusCode),
                        }
                }</span>

                <span class="cov0" title="0">var response OllamaModelsResponse
                if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                        return ModelsLoadedMsg{
                                Models: nil,
                                Error:  fmt.Errorf("failed to decode response: %w", err),
                        }
                }</span>

                <span class="cov0" title="0">return ModelsLoadedMsg{
                        Models: response.Models,
                        Error:  nil,
                }</span>
        })
}

// IsVisible returns whether the panel is visible
func (m Model) IsVisible() bool <span class="cov0" title="0">{
        return m.visible
}</span>

// GetSelectedModel returns the currently selected model name
func (m Model) GetSelectedModel() string <span class="cov0" title="0">{
        if m.loadStatus == LoadStatusLoaded &amp;&amp; len(m.models) &gt; 0 &amp;&amp; m.cursor &lt; len(m.models) </span><span class="cov0" title="0">{
                return m.models[m.cursor].Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rag

import (
        "context"
        "fmt"
        "sort"
        "time"

        v2 "github.com/amikos-tech/chroma-go/pkg/api/v2"
        "github.com/amikos-tech/chroma-go/pkg/embeddings"
        "github.com/amikos-tech/chroma-go/pkg/embeddings/ollama"
        "github.com/kevensen/gollama-chat/internal/configuration"
)

// RetrievedDocument represents a document retrieved from ChromaDB with relevance score
type RetrievedDocument struct {
        Content    string            `json:"content"`
        Metadata   map[string]string `json:"metadata"`
        Collection string            `json:"collection"`
        Distance   float32           `json:"distance"`
        ID         string            `json:"id"`
}

// RAGResult contains the retrieved documents and any errors
type RAGResult struct {
        Documents []RetrievedDocument `json:"documents"`
        Query     string              `json:"query"`
        Error     error               `json:"error,omitempty"`
}

// Service handles RAG operations using ChromaDB
type Service struct {
        config              *configuration.Config
        client              v2.Client
        embeddingFunc       embeddings.EmbeddingFunction
        connected           bool
        selectedCollections []string
}

// NewService creates a new RAG service
func NewService(config *configuration.Config) *Service <span class="cov8" title="1">{
        return &amp;Service{
                config:              config,
                connected:           false,
                selectedCollections: make([]string, 0),
        }
}</span>

// Initialize sets up the ChromaDB client and embedding function
func (s *Service) Initialize(ctx context.Context) error <span class="cov0" title="0">{
        if s.config.ChromaDBURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ChromaDB URL not configured")
        }</span>

        // Create ChromaDB client
        <span class="cov0" title="0">client, err := v2.NewHTTPClient(v2.WithBaseURL(s.config.ChromaDBURL))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create ChromaDB client: %w", err)
        }</span>

        // Test connection
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        _, err = client.ListCollections(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to ChromaDB: %w", err)
        }</span>

        // Create Ollama embedding function
        <span class="cov0" title="0">embeddingFunc, err := ollama.NewOllamaEmbeddingFunction(
                ollama.WithBaseURL(s.config.OllamaURL),
                ollama.WithModel(embeddings.EmbeddingModel(s.config.EmbeddingModel)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Ollama embedding function: %w", err)
        }</span>

        <span class="cov0" title="0">s.client = client
        s.embeddingFunc = embeddingFunc
        s.connected = true

        return nil</span>
}

// UpdateSelectedCollections updates the list of selected collections
func (s *Service) UpdateSelectedCollections(selectedCollections map[string]bool) <span class="cov0" title="0">{
        s.selectedCollections = make([]string, 0)
        for collection, selected := range selectedCollections </span><span class="cov0" title="0">{
                if selected </span><span class="cov0" title="0">{
                        s.selectedCollections = append(s.selectedCollections, collection)
                }</span>
        }
}

// IsReady checks if the service is ready to perform RAG operations
func (s *Service) IsReady() bool <span class="cov8" title="1">{
        return s.config.RAGEnabled &amp;&amp; s.connected &amp;&amp; len(s.selectedCollections) &gt; 0
}</span>

// QueryDocuments retrieves relevant documents for the given query
func (s *Service) QueryDocuments(ctx context.Context, query string) (*RAGResult, error) <span class="cov0" title="0">{
        if !s.connected </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RAG service not connected to ChromaDB")
        }</span>

        <span class="cov0" title="0">if !s.config.RAGEnabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("RAG is disabled in configuration")
        }</span>

        <span class="cov0" title="0">if len(s.selectedCollections) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no collections selected for RAG")
        }</span>

        <span class="cov0" title="0">result := &amp;RAGResult{
                Query:     query,
                Documents: make([]RetrievedDocument, 0),
        }

        // Query each selected collection
        for _, collectionName := range s.selectedCollections </span><span class="cov0" title="0">{
                docs, err := s.queryCollection(ctx, collectionName, query)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other collections
                        continue</span>
                }
                <span class="cov0" title="0">result.Documents = append(result.Documents, docs...)</span>
        }

        // Sort documents by distance (most relevant first)
        <span class="cov0" title="0">sort.Slice(result.Documents, func(i, j int) bool </span><span class="cov0" title="0">{
                return result.Documents[i].Distance &lt; result.Documents[j].Distance
        }</span>)

        // Limit total documents to maxDocuments from config
        <span class="cov0" title="0">if len(result.Documents) &gt; s.config.MaxDocuments </span><span class="cov0" title="0">{
                result.Documents = result.Documents[:s.config.MaxDocuments]
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// queryCollection queries a specific collection for relevant documents
func (s *Service) queryCollection(ctx context.Context, collectionName, query string) ([]RetrievedDocument, error) <span class="cov0" title="0">{
        // Get the collection
        collection, err := s.client.GetCollection(ctx, collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get collection %s: %w", collectionName, err)
        }</span>

        // Query the collection
        <span class="cov0" title="0">queryResult, err := collection.Query(
                ctx,
                v2.WithQueryTexts(query),
                v2.WithNResults(s.config.MaxDocuments),
                v2.WithIncludeQuery("documents", "metadatas", "distances"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query collection %s: %w", collectionName, err)
        }</span>

        <span class="cov0" title="0">documents := make([]RetrievedDocument, 0)

        // Process query results
        for groupIdx, group := range queryResult.GetDocumentsGroups() </span><span class="cov0" title="0">{
                for i, doc := range group </span><span class="cov0" title="0">{
                        // Get distance for this document
                        var distance float32 = 1.0 // Default high distance
                        if distanceGroups := queryResult.GetDistancesGroups(); len(distanceGroups) &gt; groupIdx &amp;&amp; len(distanceGroups[groupIdx]) &gt; i </span><span class="cov0" title="0">{
                                distance = float32(distanceGroups[groupIdx][i])
                        }</span>

                        // Filter by distance threshold
                        <span class="cov0" title="0">if distance &gt; float32(s.config.ChromaDBDistance) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Get metadata for this document
                        <span class="cov0" title="0">metadata := make(map[string]string)
                        if metadataGroups := queryResult.GetMetadatasGroups(); len(metadataGroups) &gt; groupIdx &amp;&amp; len(metadataGroups[groupIdx]) &gt; i </span><span class="cov0" title="0">{
                                docMetadata := metadataGroups[groupIdx][i]
                                if docMetadata != nil </span><span class="cov0" title="0">{
                                        // Type assert to DocumentMetadataImpl to access Keys() method
                                        if impl, ok := docMetadata.(*v2.DocumentMetadataImpl); ok </span><span class="cov0" title="0">{
                                                for _, key := range impl.Keys() </span><span class="cov0" title="0">{
                                                        if value, ok := impl.GetRaw(key); ok &amp;&amp; value != nil </span><span class="cov0" title="0">{
                                                                metadata[key] = fmt.Sprintf("%v", value)
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // Get document ID
                        <span class="cov0" title="0">var docID string
                        if idGroups := queryResult.GetIDGroups(); len(idGroups) &gt; groupIdx &amp;&amp; len(idGroups[groupIdx]) &gt; i </span><span class="cov0" title="0">{
                                docID = string(idGroups[groupIdx][i])
                        }</span>

                        <span class="cov0" title="0">documents = append(documents, RetrievedDocument{
                                Content:    doc.ContentString(),
                                Metadata:   metadata,
                                Collection: collectionName,
                                Distance:   distance,
                                ID:         docID,
                        })</span>
                }
        }

        <span class="cov0" title="0">return documents, nil</span>
}

// FormatDocumentsForPrompt formats retrieved documents for inclusion in chat prompt
func (r *RAGResult) FormatDocumentsForPrompt() string <span class="cov0" title="0">{
        if len(r.Documents) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var prompt string
        prompt += "=== RELEVANT CONTEXT ===\n"
        prompt += fmt.Sprintf("The following %d document(s) were retrieved to help answer your question:\n\n", len(r.Documents))

        for i, doc := range r.Documents </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf("Document %d (Collection: %s, Relevance: %.3f):\n", i+1, doc.Collection, 1.0-doc.Distance)
                prompt += doc.Content + "\n\n"
        }</span>

        <span class="cov0" title="0">prompt += "=== END CONTEXT ===\n\n"
        prompt += "Please use the above context to help answer the following question:\n"

        return prompt</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package chat

import (
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/kevensen/gollama-chat/internal/configuration"
        "github.com/kevensen/gollama-chat/internal/rag"
        "github.com/kevensen/gollama-chat/internal/tui/tabs/chat/input"
)

// Message represents a chat message
type Message struct {
        Role    string    `json:"role"` // "user" or "assistant"
        Content string    `json:"content"`
        Time    time.Time `json:"time"`
}

// Model represents the chat tab model
type Model struct {
        config           *configuration.Config
        messages         []Message
        width            int
        height           int
        scrollOffset     int
        ragService       *rag.Service
        ctx              context.Context
        tokenCount       int  // Estimated token count for current conversation
        showSystemPrompt bool // Whether to show the system prompt

        // Session system prompt feature
        sessionSystemPrompt  string // Current session system prompt (not persisted)
        systemPromptEditMode bool   // Whether we're in edit mode for the system prompt
        systemPromptEditor   string // Content being edited in the system prompt editor

        // Performance optimization: Cache model context size
        cachedModelName   string // Track which model's context size we cached
        cachedContextSize int    // Cached context size to avoid API calls during rendering

        // Optimized components
        inputModel   *input.Model
        messageCache *MessageCache
        styles       Styles

        // View caching
        cachedMessagesView      string
        cachedStatusView        string
        cachedSystemPromptView  string
        messagesNeedsUpdate     bool
        statusNeedsUpdate       bool
        systemPromptNeedsUpdate bool
}

// modelContextSizes maps model names to their approximate context window sizes
var modelContextSizes = map[string]int{
        "llama3.1":        8192,
        "llama3.1-8b":     8192,
        "llama3.1-70b":    8192,
        "llama3.2":        32768,
        "llama3.2-1b":     32768,
        "llama3.2-3b":     32768,
        "llama3.2-11b":    32768,
        "llama3.2-76b":    32768,
        "llama3.3":        128000,
        "llama3.3:latest": 128000,
        "llama3.3-8b":     128000,
        "llama3.3-70b":    128000,
        "llama3":          4096,
        "llama2":          4096,
        "mistral":         8192,
        "mistral-7b":      8192,
        "mistral-8x7b":    32768,
        "mixtral-8x7b":    32768,
        "codegemma":       32768,
        "gemma":           8192,
        "phi3":            4096,
        "neural-chat":     8192,
        "codellama":       16384,
        "llava":           4096,
        "vicuna":          4096,
        "orca-mini":       4096,
        "stable-lm":       4096,
        "mpt":             8192,
        "dolphin-phi":     4096,
}

// debugLog writes debug messages to a file for troubleshooting
func debugLog(message string) <span class="cov0" title="0">{
        f, err := os.OpenFile("/tmp/gollama-debug.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        timestamp := time.Now().Format("15:04:05.000")
        f.WriteString(fmt.Sprintf("[%s] %s\n", timestamp, message))</span>
}

// NewModel creates a new chat model
func NewModel(ctx context.Context, config *configuration.Config) Model <span class="cov0" title="0">{
        // Initialize RAG service
        ragService := rag.NewService(config)

        // Initialize input component
        inputModel := input.NewModel()

        // Create message cache
        messageCache := NewMessageCache()

        return Model{
                config:                  config,
                messages:                []Message{},
                ragService:              ragService,
                ctx:                     ctx,
                inputModel:              &amp;inputModel,
                messageCache:            messageCache,
                styles:                  DefaultStyles(),
                messagesNeedsUpdate:     true,
                statusNeedsUpdate:       true,
                systemPromptNeedsUpdate: true,
                showSystemPrompt:        false,                      // Initially hidden
                sessionSystemPrompt:     config.DefaultSystemPrompt, // Initialize with default
                systemPromptEditMode:    false,
                systemPromptEditor:      "",
        }
}</span>

// sendMessageMsg is sent when a message should be sent to Ollama
type sendMessageMsg struct {
        message string
}

// responseMsg is sent when a response is received from Ollama
type responseMsg struct {
        content string
        err     error
}

// ragStatusMsg is sent to update RAG status in the input
type ragStatusMsg struct {
        status string
}

// Init initializes the chat model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        var cmds []tea.Cmd

        // Initialize RAG service if it's enabled
        if m.config.RAGEnabled </span><span class="cov0" title="0">{
                ragCmd := tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                        err := m.ragService.Initialize(m.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                // Just log the error, don't prevent the app from starting
                                return nil
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">cmds = append(cmds, ragCmd)</span>
        }

        // Pre-fetch model context size in background to avoid UI blocking
        <span class="cov0" title="0">contextCmd := tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                // This runs in background and updates the cache
                if m.config != nil &amp;&amp; m.config.ChatModel != "" </span><span class="cov0" title="0">{
                        // Force a context size fetch to populate cache
                        _ = m.getModelContextSize(m.config.ChatModel)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">cmds = append(cmds, contextCmd)

        if len(cmds) &gt; 0 </span><span class="cov0" title="0">{
                return tea.Batch(cmds...)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Update handles messages and updates the chat model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{

        // Handle window size changes first
        if windowMsg, ok := msg.(tea.WindowSizeMsg); ok </span><span class="cov0" title="0">{
                // Store previous dimensions to detect actual changes
                prevWidth, prevHeight := m.width, m.height

                m.width = windowMsg.Width
                m.height = windowMsg.Height

                // Update the input model size with fixed height
                m.inputModel.SetSize(windowMsg.Width, 3)

                // Only indicate views need refreshing if dimensions actually changed
                if prevWidth != m.width || prevHeight != m.height </span><span class="cov0" title="0">{
                        m.messagesNeedsUpdate = true
                        m.statusNeedsUpdate = true

                        // Invalidate message cache as we need to recalculate message wrapping
                        m.messageCache.InvalidateCache()
                }</span>

                <span class="cov0" title="0">return m, nil</span>
        }

        // Handle key messages by first checking for chat-level controls, then delegating to input
        <span class="cov0" title="0">if keyMsg, ok := msg.(tea.KeyMsg); ok </span><span class="cov0" title="0">{
                // Don't process certain keys while loading
                if m.inputModel.IsLoading() &amp;&amp; keyMsg.String() != "ctrl+c" &amp;&amp; keyMsg.String() != "ctrl+l" </span><span class="cov0" title="0">{
                        return m, nil
                }</span>

                // Fast path for text input - delegate immediately to input component for maximum responsiveness
                <span class="cov0" title="0">key := keyMsg.String()
                if len(key) == 1 &amp;&amp; key &gt;= " " &amp;&amp; key &lt;= "~" </span><span class="cov0" title="0">{
                        // DEBUG: Log character input and current state
                        debugLog(fmt.Sprintf("Character '%s', systemPromptEditMode=%t, showSystemPrompt=%t", key, m.systemPromptEditMode, m.showSystemPrompt))
                        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                                // Handle text input for system prompt editing
                                debugLog(fmt.Sprintf("Adding '%s' to system prompt editor", key))
                                m.systemPromptEditor += key
                                m.systemPromptNeedsUpdate = true
                                return m, nil
                        }</span> else<span class="cov0" title="0"> {
                                debugLog(fmt.Sprintf("Delegating '%s' to input model", key))
                                updatedInputModel, cmd := m.inputModel.Update(msg)
                                m.inputModel = &amp;updatedInputModel
                                return m, cmd
                        }</span>
                }

                // Handle chat-level control keys
                <span class="cov0" title="0">switch key </span>{
                case "enter":<span class="cov0" title="0">
                        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                                // Add newline to system prompt editor
                                m.systemPromptEditor += "\n"
                                m.systemPromptNeedsUpdate = true
                                return m, nil
                        }</span> else<span class="cov0" title="0"> if strings.TrimSpace(m.inputModel.Value()) != "" </span><span class="cov0" title="0">{
                                // Add user message
                                userMsg := Message{
                                        Role:    "user",
                                        Content: m.inputModel.Value(),
                                        Time:    time.Now(),
                                }
                                m.messages = append(m.messages, userMsg)

                                // Get the prompt and reset input
                                prompt := m.inputModel.Value()
                                m.inputModel.Clear()
                                m.inputModel.SetLoading(true)

                                // Set initial RAG status if RAG is enabled
                                if m.config.RAGEnabled </span><span class="cov0" title="0">{
                                        if m.ragService != nil &amp;&amp; m.ragService.IsReady() </span><span class="cov0" title="0">{
                                                m.inputModel.SetRAGStatus("Searching documents...")
                                        }</span> else<span class="cov0" title="0"> {
                                                m.inputModel.SetRAGStatus("RAG not ready")
                                        }</span>
                                }

                                // Mark messages for update
                                <span class="cov0" title="0">m.messagesNeedsUpdate = true
                                m.messageCache.InvalidateCache()

                                // Update token count after adding user message
                                m.updateTokenCount()
                                m.statusNeedsUpdate = true

                                return m, m.sendMessage(prompt)</span>
                        }

                case "ctrl+s":<span class="cov0" title="0">
                        // Handle system prompt toggle and save
                        debugLog(fmt.Sprintf("Ctrl+S pressed, current state: showSystemPrompt=%t, systemPromptEditMode=%t", m.showSystemPrompt, m.systemPromptEditMode))
                        if m.showSystemPrompt &amp;&amp; m.systemPromptEditMode </span><span class="cov0" title="0">{
                                // Save the edited prompt and exit edit mode
                                debugLog("Saving prompt and exiting edit mode")
                                m.sessionSystemPrompt = m.systemPromptEditor
                                m.systemPromptEditMode = false
                                m.systemPromptEditor = ""
                                m.systemPromptNeedsUpdate = true
                                return m, nil
                        }</span> else<span class="cov0" title="0"> if m.showSystemPrompt </span><span class="cov0" title="0">{
                                // Close system prompt pane
                                debugLog("Closing system prompt pane")
                                m.showSystemPrompt = false
                                m.systemPromptNeedsUpdate = true
                                m.messagesNeedsUpdate = true // Force layout refresh
                                return m, nil
                        }</span> else<span class="cov0" title="0"> {
                                // Open system prompt pane
                                debugLog("Opening system prompt pane")
                                m.showSystemPrompt = true
                                m.systemPromptNeedsUpdate = true
                                m.messagesNeedsUpdate = true // Force layout refresh
                                return m, nil
                        }</span>

                case "ctrl+e":<span class="cov0" title="0">
                        // Enter edit mode for system prompt - open pane if needed
                        debugLog(fmt.Sprintf("Ctrl+E pressed, current state: showSystemPrompt=%t, systemPromptEditMode=%t", m.showSystemPrompt, m.systemPromptEditMode))
                        if !m.showSystemPrompt </span><span class="cov0" title="0">{
                                // Open system prompt pane if it's not visible
                                m.showSystemPrompt = true
                                m.messagesNeedsUpdate = true // Force layout refresh
                                debugLog("Opened system prompt pane")
                        }</span>
                        // Always enter edit mode and clear the prompt
                        <span class="cov0" title="0">m.systemPromptEditMode = true
                        m.systemPromptEditor = "" // Clear the prompt as requested
                        m.systemPromptNeedsUpdate = true
                        debugLog("Set systemPromptEditMode=true, cleared editor")
                        return m, nil</span>

                case "ctrl+r":<span class="cov0" title="0">
                        // Restore default system prompt when in edit mode
                        if m.showSystemPrompt &amp;&amp; m.systemPromptEditMode </span><span class="cov0" title="0">{
                                m.systemPromptEditor = m.config.DefaultSystemPrompt
                                m.systemPromptNeedsUpdate = true
                                return m, nil
                        }</span>

                case "ctrl+l":<span class="cov0" title="0">
                        // Clear chat
                        m.messages = []Message{}
                        m.scrollOffset = 0
                        m.messagesNeedsUpdate = true
                        m.messageCache.InvalidateCache()
                        return m, nil</span>

                case "backspace", "left", "right", "home", "end", "ctrl+a":<span class="cov0" title="0">
                        // Delegate cursor and deletion operations directly to input
                        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                                // Handle system prompt editing keys
                                switch key </span>{
                                case "backspace":<span class="cov0" title="0">
                                        if len(m.systemPromptEditor) &gt; 0 </span><span class="cov0" title="0">{
                                                m.systemPromptEditor = m.systemPromptEditor[:len(m.systemPromptEditor)-1]
                                                m.systemPromptNeedsUpdate = true
                                        }</span>
                                }
                                <span class="cov0" title="0">return m, nil</span>
                        } else<span class="cov0" title="0"> {
                                updatedInputModel, cmd := m.inputModel.Update(msg)
                                m.inputModel = &amp;updatedInputModel
                                return m, cmd
                        }</span>

                case "up":<span class="cov0" title="0">
                        if m.scrollOffset &gt; 0 </span><span class="cov0" title="0">{
                                m.scrollOffset--
                                m.messagesNeedsUpdate = true
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "down":<span class="cov0" title="0">
                        // Calculate max scroll
                        messagesHeight := m.messageCache.GetTotalHeight(&amp;m)

                        // Get system prompt height
                        systemPromptHeight := m.getSystemPromptHeight()
                        availableHeight := m.height - 6 - systemPromptHeight // Reserve space for input area, status bar, and system prompt

                        if messagesHeight &gt; availableHeight </span><span class="cov0" title="0">{
                                maxScroll := messagesHeight - availableHeight
                                if m.scrollOffset &lt; maxScroll </span><span class="cov0" title="0">{
                                        m.scrollOffset++
                                        m.messagesNeedsUpdate = true
                                }</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "pgup":<span class="cov0" title="0">
                        // Page Up - scroll up by available height
                        systemPromptHeight := m.getSystemPromptHeight()
                        availableHeight := m.height - 6 - systemPromptHeight // Reserve space for input area, status bar, and system prompt
                        pageSize := availableHeight - 1                      // Leave one line for context
                        if pageSize &lt; 1 </span><span class="cov0" title="0">{
                                pageSize = 1
                        }</span>

                        <span class="cov0" title="0">m.scrollOffset -= pageSize
                        if m.scrollOffset &lt; 0 </span><span class="cov0" title="0">{
                                m.scrollOffset = 0
                        }</span>
                        <span class="cov0" title="0">m.messagesNeedsUpdate = true
                        return m, nil</span>

                case "pgdown":<span class="cov0" title="0">
                        // Page Down - scroll down by available height
                        systemPromptHeight := m.getSystemPromptHeight()
                        availableHeight := m.height - 6 - systemPromptHeight // Reserve space for input area, status bar, and system prompt
                        pageSize := max(
                                // Leave one line for context
                                availableHeight-1, 1)

                        messagesHeight := m.messageCache.GetTotalHeight(&amp;m)
                        if messagesHeight &gt; availableHeight </span><span class="cov0" title="0">{
                                maxScroll := messagesHeight - availableHeight
                                m.scrollOffset += pageSize
                                if m.scrollOffset &gt; maxScroll </span><span class="cov0" title="0">{
                                        m.scrollOffset = maxScroll
                                }</span>
                                <span class="cov0" title="0">m.messagesNeedsUpdate = true</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                default:<span class="cov0" title="0">
                        // For all other keys, delegate to input component for maximum responsiveness
                        // This includes character input, special key combinations, etc.
                        debugLog(fmt.Sprintf("Default case: key='%s', systemPromptEditMode=%t", key, m.systemPromptEditMode))
                        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                                // Handle text input for system prompt editing
                                if len(key) == 1 &amp;&amp; key &gt;= " " &amp;&amp; key &lt;= "~" </span><span class="cov0" title="0">{
                                        debugLog(fmt.Sprintf("Default case: Adding '%s' to system prompt editor", key))
                                        m.systemPromptEditor += key
                                        m.systemPromptNeedsUpdate = true
                                }</span> else<span class="cov0" title="0"> {
                                        debugLog(fmt.Sprintf("Default case: Non-printable key '%s' ignored in edit mode", key))
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>
                        } else<span class="cov0" title="0"> {
                                debugLog(fmt.Sprintf("Default case: Delegating '%s' to input model", key))
                                updatedInputModel, cmd := m.inputModel.Update(msg)
                                m.inputModel = &amp;updatedInputModel
                                return m, cmd
                        }</span>
                }
        }

        // Handle other message types
        <span class="cov0" title="0">switch msg := msg.(type) </span>{

        case sendMessageMsg:<span class="cov0" title="0">
                return m, m.sendMessage(msg.message)</span>

        case ragStatusMsg:<span class="cov0" title="0">
                // Update the input's RAG status
                m.inputModel.SetRAGStatus(msg.status)
                return m, nil</span>

        case responseMsg:<span class="cov0" title="0">
                m.inputModel.SetLoading(false)
                if msg.err != nil </span><span class="cov0" title="0">{
                        // Add error message
                        errorMsg := Message{
                                Role:    "assistant",
                                Content: fmt.Sprintf("Error: %s", msg.err.Error()),
                                Time:    time.Now(),
                        }
                        m.messages = append(m.messages, errorMsg)
                }</span> else<span class="cov0" title="0"> {
                        // Add assistant response
                        assistantMsg := Message{
                                Role:    "assistant",
                                Content: msg.content,
                                Time:    time.Now(),
                        }
                        m.messages = append(m.messages, assistantMsg)
                }</span>

                // Mark messages for update but preserve layout dimensions
                <span class="cov0" title="0">m.messagesNeedsUpdate = true
                m.messageCache.InvalidateCache()

                // Update token count
                m.updateTokenCount()
                m.statusNeedsUpdate = true

                // Auto-scroll to bottom without changing dimensions
                m.scrollToBottom()</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the chat tab
func (m Model) View() string <span class="cov0" title="0">{
        if m.width == 0 || m.height == 0 </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>

        // Ensure consistent rendering regardless of scroll state or message count

        // Prepare the components only if they need updating
        <span class="cov0" title="0">var messagesView, statusView, systemPromptView string

        // System prompt view - only show if enabled
        var components []string
        if m.showSystemPrompt </span><span class="cov0" title="0">{
                if m.systemPromptNeedsUpdate || m.cachedSystemPromptView == "" </span><span class="cov0" title="0">{
                        systemPromptView = m.renderSystemPrompt()
                        m.cachedSystemPromptView = systemPromptView
                        m.systemPromptNeedsUpdate = false
                }</span> else<span class="cov0" title="0"> {
                        systemPromptView = m.cachedSystemPromptView
                }</span>
                <span class="cov0" title="0">components = append(components, systemPromptView)</span>
        }

        // Messages view - only recompute if needed
        <span class="cov0" title="0">if m.messagesNeedsUpdate || m.cachedMessagesView == "" </span><span class="cov0" title="0">{
                messagesView = m.messageCache.RenderAllMessages(&amp;m)
                m.cachedMessagesView = messagesView
                m.messagesNeedsUpdate = false
        }</span> else<span class="cov0" title="0"> {
                messagesView = m.cachedMessagesView
        }</span>
        <span class="cov0" title="0">components = append(components, messagesView)

        // Status bar - only recompute if needed
        if m.statusNeedsUpdate || m.cachedStatusView == "" </span><span class="cov0" title="0">{
                statusView = m.renderStatusBar()
                m.cachedStatusView = statusView
                m.statusNeedsUpdate = false
        }</span> else<span class="cov0" title="0"> {
                statusView = m.cachedStatusView
        }</span>
        <span class="cov0" title="0">components = append(components, statusView)

        // Input view - render directly without caching for maximum responsiveness
        // Use a simpler rendering approach to minimize latency
        inputView := m.inputModel.View()
        components = append(components, inputView)

        // Join all components vertically with minimal processing
        return lipgloss.JoinVertical(
                lipgloss.Left,
                components...,
        )</span>
}

// scrollToBottom scrolls to the bottom of the messages
func (m Model) scrollToBottom() <span class="cov0" title="0">{
        messagesHeight := m.calculateMessagesHeight()

        // Get system prompt height
        systemPromptHeight := m.getSystemPromptHeight()

        availableHeight := m.height - 6 - systemPromptHeight // Adjust for input area, status bar and system prompt
        if messagesHeight &gt; availableHeight </span><span class="cov0" title="0">{
                m.scrollOffset = messagesHeight - availableHeight
        }</span> else<span class="cov0" title="0"> {
                m.scrollOffset = 0
        }</span>
        // Don't trigger resize/reflow of the overall UI when scrolling
}

// wrapText wraps text to fit within the specified width
func (m Model) wrapText(text string, width int) []string <span class="cov0" title="0">{
        // Early return for edge cases
        if width &lt;= 0 </span><span class="cov0" title="0">{
                return []string{text}
        }</span>

        // Optimization for short texts that don't need wrapping
        <span class="cov0" title="0">if len(text) &lt;= width </span><span class="cov0" title="0">{
                return []string{text}
        }</span>

        <span class="cov0" title="0">words := strings.Fields(text)
        if len(words) == 0 </span><span class="cov0" title="0">{
                return []string{""}
        }</span>

        // Preallocate the result slice based on an estimate
        <span class="cov0" title="0">estimatedLines := (len(text) / width) + 1
        lines := make([]string, 0, estimatedLines)

        // Use strings.Builder for better performance
        var sb strings.Builder

        for _, word := range words </span><span class="cov0" title="0">{
                // Check if adding this word would exceed the width
                if sb.Len() == 0 </span><span class="cov0" title="0">{
                        sb.WriteString(word)
                }</span> else<span class="cov0" title="0"> if sb.Len()+len(word)+1 &lt;= width </span><span class="cov0" title="0">{
                        sb.WriteString(" ")
                        sb.WriteString(word)
                }</span> else<span class="cov0" title="0"> {
                        // Line is full, append it and start a new one
                        lines = append(lines, sb.String())
                        sb.Reset()
                        sb.WriteString(word)
                }</span>
        }

        // Add the last line if there's anything left
        <span class="cov0" title="0">if sb.Len() &gt; 0 </span><span class="cov0" title="0">{
                lines = append(lines, sb.String())
        }</span>

        <span class="cov0" title="0">return lines</span>
}

// renderStatusBar renders the status bar showing model and token information
func (m *Model) renderStatusBar() string <span class="cov0" title="0">{
        // Use the pre-defined style from styles.go
        statusStyle := m.styles.statusBar.Width(m.width - 2)

        // Get model name
        modelInfo := fmt.Sprintf("Model: %s", m.config.ChatModel)

        // Get context window size efficiently (NEVER make API calls during render!)
        contextSize := m.getCachedModelContextSize()
        contextInfo := fmt.Sprintf("Context: %d", contextSize)

        // Get token information
        tokenInfo := fmt.Sprintf("Tokens: ~%d", m.tokenCount)

        // Calculate percentage of context used
        percentUsed := 0
        if contextSize &gt; 0 </span><span class="cov0" title="0">{
                percentUsed = (m.tokenCount * 100) / contextSize
                if percentUsed &gt; 100 </span><span class="cov0" title="0">{
                        percentUsed = 100
                }</span>
        }

        // Combine information with spacing
        <span class="cov0" title="0">status := fmt.Sprintf("%s | %s | %s (%d%%)", modelInfo, contextInfo, tokenInfo, percentUsed)

        return statusStyle.Render(status)</span>
}

// getCachedModelContextSize returns the context size for the current model,
// using ONLY cached/fallback values to ensure zero latency during rendering
func (m *Model) getCachedModelContextSize() int <span class="cov0" title="0">{
        // Check if we have the context size cached for the current model
        if m.cachedModelName == m.config.ChatModel &amp;&amp; m.cachedContextSize &gt; 0 </span><span class="cov0" title="0">{
                return m.cachedContextSize
        }</span>

        // ALWAYS use fallback values for immediate rendering (NEVER make API calls!)
        // This ensures UI responsiveness at all times
        <span class="cov0" title="0">contextSize := getFallbackContextSize(m.config.ChatModel)

        // Cache the fallback result immediately
        m.cachedModelName = m.config.ChatModel
        m.cachedContextSize = contextSize

        return contextSize</span>
}

// GetRAGService returns the RAG service for external access
func (m Model) GetRAGService() *rag.Service <span class="cov0" title="0">{
        return m.ragService
}</span>

// HandleFastInputChar handles ASCII input characters with zero overhead
// Returns true if the character was handled (fast path), false if normal processing should continue
func (m *Model) HandleFastInputChar(char rune) bool <span class="cov0" title="0">{
        // Only handle ASCII printable characters
        if char &lt; 32 || char &gt; 126 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Don't handle input if loading
        <span class="cov0" title="0">if m.inputModel.IsLoading() </span><span class="cov0" title="0">{
                return false
        }</span>

        // DEBUG: Log character input and current state
        <span class="cov0" title="0">debugLog(fmt.Sprintf("HandleFastInputChar: char='%c', systemPromptEditMode=%t, showSystemPrompt=%t", char, m.systemPromptEditMode, m.showSystemPrompt))

        // Check if we're in system prompt edit mode
        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                // Handle text input for system prompt editing
                debugLog(fmt.Sprintf("HandleFastInputChar: Adding '%c' to system prompt editor", char))
                m.systemPromptEditor += string(char)
                m.systemPromptNeedsUpdate = true
                return true
        }</span>

        // Direct character insertion to input model with zero overhead
        <span class="cov0" title="0">debugLog(fmt.Sprintf("HandleFastInputChar: Adding '%c' to input model", char))
        m.inputModel.InsertCharacterDirect(char)
        return true</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package input

import (
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Model represents an optimized input field for text entry
type Model struct {
        value     string         // Current input text
        cursor    int            // Cursor position
        width     int            // Available width for rendering
        height    int            // Height of input box
        style     lipgloss.Style // Style for the input box (unused but kept for compatibility)
        prompt    string         // Prompt prefix before the input
        loading   bool           // Whether the input is in loading state
        ragStatus string         // RAG status message to display during loading
}

// NewModel creates a new input model
func NewModel() Model <span class="cov0" title="0">{
        // Restore the border styling for better visual appearance
        style := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("#8A7FD8")). // Use same purple color as messages border
                Height(3).
                Padding(0, 1) // Add horizontal padding for better readability

        return Model{
                value:     "",
                cursor:    0,
                width:     80, // Default width
                height:    3,
                style:     style,
                prompt:    "&gt; ",
                loading:   false,
                ragStatus: "",
        }
}</span>

// SetLoading sets the loading state
func (m *Model) SetLoading(loading bool) <span class="cov0" title="0">{
        m.loading = loading
        if !loading </span><span class="cov0" title="0">{
                m.ragStatus = "" // Clear RAG status when done loading
        }</span>
}

// SetRAGStatus sets the RAG status message
func (m *Model) SetRAGStatus(status string) <span class="cov0" title="0">{
        m.ragStatus = status
}</span>

// IsLoading returns whether the input is in loading state
func (m Model) IsLoading() bool <span class="cov0" title="0">{
        return m.loading
}</span>

// SetSize updates the dimensions of the input component
func (m *Model) SetSize(width, height int) <span class="cov0" title="0">{
        // Update styling with new dimensions
        const fixedHeight = 3
        if m.width != width </span><span class="cov0" title="0">{
                m.width = width
                m.height = fixedHeight
                m.style = m.style.Width(width - 2).Height(fixedHeight) // Adjust for border
        }</span>
}

// Value returns the current input text
func (m Model) Value() string <span class="cov0" title="0">{
        return m.value
}</span>

// SetValue sets the input value and refreshes the display
func (m *Model) SetValue(value string) <span class="cov0" title="0">{
        m.value = value
        m.cursor = len(value)
}</span>

// InsertCharacterDirect inserts a character at cursor without any overhead (ultra-fast path)
func (m *Model) InsertCharacterDirect(char rune) <span class="cov0" title="0">{
        if m.cursor == len(m.value) </span><span class="cov0" title="0">{
                // Fast append for most common case
                m.value += string(char)
        }</span> else<span class="cov0" title="0"> {
                // Manual slice manipulation for mid-insertion
                newValue := make([]byte, 0, len(m.value)+4) // UTF-8 safety margin
                newValue = append(newValue, m.value[:m.cursor]...)
                newValue = append(newValue, string(char)...)
                newValue = append(newValue, m.value[m.cursor:]...)
                m.value = string(newValue)
        }</span>
        <span class="cov0" title="0">m.cursor++</span>
}

// CursorPosition returns the current cursor position
func (m Model) CursorPosition() int <span class="cov0" title="0">{
        return m.cursor
}</span>

// Clear resets the input value
func (m *Model) Clear() <span class="cov0" title="0">{
        m.value = ""
        m.cursor = 0
}</span>

// Update handles events for the input component
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) <span class="cov0" title="0">{
        // Skip processing if in loading state
        if m.loading </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                // NOTE: ASCII characters should now be handled by the ultra-fast path in TUI
                // This is a fallback for non-ASCII or when ultra-fast path is disabled
                if msg.Type == tea.KeyRunes &amp;&amp; len(msg.Runes) == 1 </span><span class="cov0" title="0">{
                        char := msg.Runes[0]
                        if char &gt;= 32 &amp;&amp; char &lt;= 126 </span><span class="cov0" title="0">{ // ASCII printable
                                // Direct character insertion using the same fast method
                                m.InsertCharacterDirect(char)
                                return m, nil
                        }</span>
                }
                <span class="cov0" title="0">return m.handleKeyMsg(msg)</span>
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.SetSize(msg.Width, 3) // Keep height fixed
                return m, nil</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// Backspace removes a character at the current cursor position
func (m *Model) Backspace() <span class="cov0" title="0">{
        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                if m.cursor &lt; len(m.value) </span><span class="cov0" title="0">{
                        // Delete at cursor position
                        m.value = m.value[:m.cursor-1] + m.value[m.cursor:]
                }</span> else<span class="cov0" title="0"> {
                        // More efficient path for deleting at end
                        m.value = m.value[:m.cursor-1]
                }</span>
                <span class="cov0" title="0">m.cursor--</span>
        }
}

// MoveCursorLeft moves the cursor one position to the left
func (m *Model) MoveCursorLeft() <span class="cov0" title="0">{
        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                m.cursor--
        }</span>
}

// MoveCursorRight moves the cursor one position to the right
func (m *Model) MoveCursorRight() <span class="cov0" title="0">{
        if m.cursor &lt; len(m.value) </span><span class="cov0" title="0">{
                m.cursor++
        }</span>
}

// InsertCharacter inserts a character at the current cursor position
func (m *Model) InsertCharacter(char string) <span class="cov0" title="0">{
        if len(char) != 1 </span><span class="cov0" title="0">{
                return
        }</span>

        // Fast path for appending at end (most common case)
        <span class="cov0" title="0">if m.cursor == len(m.value) </span><span class="cov0" title="0">{
                m.value += char
        }</span> else<span class="cov0" title="0"> {
                // Insert in the middle using efficient string manipulation
                var sb strings.Builder
                sb.Grow(len(m.value) + 1)
                sb.WriteString(m.value[:m.cursor])
                sb.WriteString(char)
                sb.WriteString(m.value[m.cursor:])
                m.value = sb.String()
        }</span>
        <span class="cov0" title="0">m.cursor++</span>
}

// handleKeyMsg processes keyboard input efficiently
func (m Model) handleKeyMsg(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "backspace":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        if m.cursor &lt; len(m.value) </span><span class="cov0" title="0">{
                                // Use slice manipulation for better performance
                                result := make([]byte, 0, len(m.value)-1)
                                result = append(result, m.value[:m.cursor-1]...)
                                result = append(result, m.value[m.cursor:]...)
                                m.value = string(result)
                        }</span> else<span class="cov0" title="0"> {
                                // Simple truncation for end deletion
                                m.value = m.value[:m.cursor-1]
                        }</span>
                        <span class="cov0" title="0">m.cursor--</span>
                }
                <span class="cov0" title="0">return m, nil</span>

        case "left":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.cursor--
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "right":<span class="cov0" title="0">
                if m.cursor &lt; len(m.value) </span><span class="cov0" title="0">{
                        m.cursor++
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case "home":<span class="cov0" title="0">
                m.cursor = 0
                return m, nil</span>

        case "end":<span class="cov0" title="0">
                m.cursor = len(m.value)
                return m, nil</span>

        case "ctrl+a":<span class="cov0" title="0">
                m.cursor = 0
                return m, nil</span>

        case "ctrl+e":<span class="cov0" title="0">
                m.cursor = len(m.value)
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the input component with minimal overhead but nice styling
func (m *Model) View() string <span class="cov0" title="0">{
        // Build content efficiently using string builder for Unicode safety
        var content string

        if m.loading </span><span class="cov0" title="0">{
                // During loading, show thinking message and RAG status
                content = m.prompt + "Thinking..."
                if m.ragStatus != "" </span><span class="cov0" title="0">{
                        content += " (" + m.ragStatus + ")"
                }</span>
        } else<span class="cov0" title="0"> {
                // Pre-calculate content length to avoid multiple string operations
                valueLen := len(m.value)

                if valueLen == 0 </span><span class="cov0" title="0">{
                        // Simplified placeholder
                        content = m.prompt + "Type your question...█"
                }</span> else<span class="cov0" title="0"> if m.cursor == valueLen </span><span class="cov0" title="0">{
                        // Cursor at end - simple concatenation
                        content = m.prompt + m.value + "█"
                }</span> else<span class="cov0" title="0"> {
                        // Cursor in middle - use string builder for Unicode safety
                        var sb strings.Builder
                        sb.Grow(len(m.prompt) + valueLen + 3) // Pre-allocate capacity
                        sb.WriteString(m.prompt)
                        sb.WriteString(m.value[:m.cursor])
                        sb.WriteString("█")
                        sb.WriteString(m.value[m.cursor:])
                        content = sb.String()
                }</span>
        }

        // Apply styling efficiently
        <span class="cov0" title="0">return m.style.Render(content)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package chat

import (
        "strings"
)

// MessageCache stores precomputed message renders to avoid recalculations
type MessageCache struct {
        // Rendered messages cache
        renderedMessages map[string][]string

        // Last window width used for rendering
        lastWidth int

        // Flag to indicate if cache needs to be invalidated
        needsRefresh bool

        // The last computed total height of all messages
        cachedTotalHeight int
}

// NewMessageCache creates a new message cache
func NewMessageCache() *MessageCache <span class="cov0" title="0">{
        return &amp;MessageCache{
                renderedMessages: make(map[string][]string),
                needsRefresh:     true,
        }
}</span>

// GetRenderedMessage gets a precomputed message or computes and caches it
func (c *MessageCache) GetRenderedMessage(model *Model, msg Message, width int) []string <span class="cov0" title="0">{
        // Generate a cache key for the message
        key := msg.Role + msg.Time.String() + msg.Content

        // Check if width changed - if so we need to invalidate cache
        if width != c.lastWidth </span><span class="cov0" title="0">{
                c.lastWidth = width
                c.needsRefresh = true
                c.renderedMessages = make(map[string][]string)
        }</span>

        // Return cached version if available
        <span class="cov0" title="0">if lines, ok := c.renderedMessages[key]; ok &amp;&amp; !c.needsRefresh </span><span class="cov0" title="0">{
                return lines
        }</span>

        // Compute the message rendering
        <span class="cov0" title="0">lines := model.formatMessage(msg)

        // Cache the result
        c.renderedMessages[key] = lines

        return lines</span>
}

// InvalidateCache marks the cache for refresh
func (c *MessageCache) InvalidateCache() <span class="cov0" title="0">{
        c.needsRefresh = true
}</span>

// GetTotalHeight gets the cached height or computes it
func (c *MessageCache) GetTotalHeight(model *Model) int <span class="cov0" title="0">{
        if !c.needsRefresh &amp;&amp; c.cachedTotalHeight &gt; 0 </span><span class="cov0" title="0">{
                return c.cachedTotalHeight
        }</span>

        // Compute height of all messages
        <span class="cov0" title="0">height := 0
        for _, msg := range model.messages </span><span class="cov0" title="0">{
                renderedMsg := c.GetRenderedMessage(model, msg, model.width)
                height += len(renderedMsg)
        }</span>

        <span class="cov0" title="0">c.cachedTotalHeight = height
        c.needsRefresh = false

        return height</span>
}

// RenderAllMessages renders all messages with caching
func (c *MessageCache) RenderAllMessages(model *Model) string <span class="cov0" title="0">{
        // Calculate available height for messages, accounting for system prompt
        systemPromptHeight := model.getSystemPromptHeight()
        availableHeight := model.height - 6 - systemPromptHeight // Reserve space for input, status, and system prompt

        // Apply styling with border regardless of message count
        messageStyle := model.styles.messages.
                Width(model.width - 2). // Account for border width
                Height(availableHeight) // Use calculated available height

        if len(model.messages) == 0 </span><span class="cov0" title="0">{
                emptyStyle := model.styles.emptyMessages.
                        Width(model.width - 4).     // Account for parent border and padding
                        Height(availableHeight - 2) // Account for parent border and padding

                return messageStyle.Render(emptyStyle.Render("No messages yet. Type a message and press Enter to start chatting!"))
        }</span>

        <span class="cov0" title="0">var allLines []string

        // Get all rendered message lines
        for _, msg := range model.messages </span><span class="cov0" title="0">{
                lines := c.GetRenderedMessage(model, msg, model.width-4) // Account for border width
                allLines = append(allLines, lines...)
        }</span>

        // Calculate the visible portion based on scroll offset
        // Use the same availableHeight calculated above
        <span class="cov0" title="0">totalLines := len(allLines)

        // Apply scroll offset
        if totalLines &lt;= availableHeight </span><span class="cov0" title="0">{
                // All lines fit, no scrolling needed
                model.scrollOffset = 0
        }</span> else<span class="cov0" title="0"> {
                // Get the visible slice of lines
                startIdx := model.scrollOffset
                endIdx := startIdx + availableHeight

                // Bounds checking
                if endIdx &gt; totalLines </span><span class="cov0" title="0">{
                        endIdx = totalLines
                        startIdx = endIdx - availableHeight
                        if startIdx &lt; 0 </span><span class="cov0" title="0">{
                                startIdx = 0
                        }</span>
                }

                <span class="cov0" title="0">allLines = allLines[startIdx:endIdx]</span>
        }

        // Render final content with proper styling and ensure consistent dimensions
        <span class="cov0" title="0">content := strings.Join(allLines, "\n")

        // Use the pre-sized style created above
        return messageStyle.Render(content)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package chat

import (
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/ollama/ollama/api"
)

// sendMessage sends a message to Ollama using the Ollama API client
func (m Model) sendMessage(prompt string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                var fullPrompt string

                // If RAG is enabled, use it to retrieve relevant documents
                if m.config.RAGEnabled &amp;&amp; m.ragService != nil &amp;&amp; m.ragService.IsReady() </span><span class="cov0" title="0">{
                        ragResult, err := m.ragService.QueryDocuments(m.ctx, prompt)
                        if err == nil &amp;&amp; ragResult != nil &amp;&amp; len(ragResult.Documents) &gt; 0 </span><span class="cov0" title="0">{
                                // Add formatted RAG documents to the prompt
                                fullPrompt = ragResult.FormatDocumentsForPrompt() + prompt
                        }</span> else<span class="cov0" title="0"> {
                                fullPrompt = prompt
                        }</span>
                } else<span class="cov0" title="0"> {
                        fullPrompt = prompt
                }</span>

                // Create Ollama client with better error handling
                <span class="cov0" title="0">_, err := api.ClientFromEnvironment()
                if err != nil </span><span class="cov0" title="0">{
                        return responseMsg{err: fmt.Errorf("failed to create Ollama client: %w", err)}
                }</span>

                // Override the client's base URL with the configured Ollama URL
                <span class="cov0" title="0">baseURL, err := url.Parse(m.config.OllamaURL)
                if err != nil </span><span class="cov0" title="0">{
                        return responseMsg{err: fmt.Errorf("invalid Ollama URL %s: %w", m.config.OllamaURL, err)}
                }</span>
                <span class="cov0" title="0">client := api.NewClient(baseURL, &amp;http.Client{
                        Timeout: 60 * time.Second, // Add a reasonable timeout
                })

                // Convert chat messages to Ollama api.Message format
                var messages []api.Message

                // Add system prompt if configured
                if m.sessionSystemPrompt != "" </span><span class="cov0" title="0">{
                        messages = append(messages, api.Message{
                                Role:    "system",
                                Content: m.sessionSystemPrompt,
                        })
                }</span>

                // Add all previous messages as context (preserving message history)
                <span class="cov0" title="0">for _, msg := range m.messages </span><span class="cov0" title="0">{
                        messages = append(messages, api.Message{
                                Role:    msg.Role,
                                Content: msg.Content,
                        })
                }</span>

                // Add the current user message with RAG context if available
                <span class="cov0" title="0">messages = append(messages, api.Message{
                        Role:    "user",
                        Content: fullPrompt,
                })

                // Set options
                options := map[string]any{
                        "temperature":    0.7,
                        "repeat_last_n":  2,
                        "repeat_penalty": 1.1,
                }

                // Create chat request with stream enabled (true is default, but we're explicit)
                stream := true
                chatRequest := &amp;api.ChatRequest{
                        Model:    m.config.ChatModel,
                        Messages: messages,
                        Stream:   &amp;stream,
                        Options:  options,
                }

                // Use ChatStream for real-time response with enhanced error handling
                var fullResponse strings.Builder
                var responseErr error

                err = client.Chat(m.ctx, chatRequest, func(response api.ChatResponse) error </span><span class="cov0" title="0">{
                        // Check for context cancellation
                        if m.ctx.Err() != nil </span><span class="cov0" title="0">{
                                responseErr = m.ctx.Err()
                                return responseErr
                        }</span>

                        <span class="cov0" title="0">fullResponse.WriteString(response.Message.Content)
                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        if responseErr != nil </span><span class="cov0" title="0">{
                                return responseMsg{err: fmt.Errorf("chat response error: %w", responseErr)}
                        }</span>
                        <span class="cov0" title="0">return responseMsg{err: fmt.Errorf("chat request failed: %w", err)}</span>
                }

                <span class="cov0" title="0">return responseMsg{content: fullResponse.String()}</span>
        })
}

// calculateMessagesHeight calculates the total height of all messages
// with optimized performance
func (m Model) calculateMessagesHeight() int <span class="cov0" title="0">{
        // Cache message heights to avoid recomputing them repeatedly
        height := 0

        // Quick estimate if messages haven't changed
        if len(m.messages) &gt; 0 </span><span class="cov0" title="0">{
                for _, msg := range m.messages </span><span class="cov0" title="0">{
                        // Basic calculation: 1 line for header + content lines + 1 line for spacing
                        contentWidth := m.width - 4 // Account for border
                        wrappedLines := len(m.wrapText(msg.Content, contentWidth))
                        height += 1 + wrappedLines + 1
                }</span>
        }

        <span class="cov0" title="0">return height</span>
}

// formatMessage formats a single message for display with performance optimization
func (m Model) formatMessage(msg Message) []string <span class="cov0" title="0">{
        // Preallocate slice with estimated capacity to avoid reallocations
        estimatedCapacity := 10 // header + some content lines + spacing
        lines := make([]string, 0, estimatedCapacity)

        // Header with role and timestamp
        timeStr := msg.Time.Format("15:04:05")

        // Use styles from the styles struct for better maintainability
        var header string
        if msg.Role == "user" </span><span class="cov0" title="0">{
                header = m.styles.userHeader.Render(fmt.Sprintf("User [%s]", timeStr))
        }</span> else<span class="cov0" title="0"> {
                header = m.styles.assistantHeader.Render(fmt.Sprintf("Assistant [%s]", timeStr))
        }</span>
        <span class="cov0" title="0">lines = append(lines, header)

        // Message content (wrap to fit width)
        contentWidth := m.width - 4 // Account for border
        wrappedContent := m.wrapText(msg.Content, contentWidth)
        lines = append(lines, wrappedContent...)

        // Add spacing
        lines = append(lines, "")

        return lines</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package chat

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "sync"
        "time"
)

// Cache for model context sizes to avoid repeated API calls
var contextSizeCache = make(map[string]int)
var contextSizeCacheMutex sync.RWMutex

// OllamaModelInfo represents the model_info section of the show API response
type OllamaModelInfo struct {
        ContextLength        int `json:"llama.context_length"`
        GeneralContextLength int `json:"general.context_length"`
}

// OllamaShowResponse represents the response from /api/show
type OllamaShowResponse struct {
        ModelInfo OllamaModelInfo `json:"model_info"`
}

// getModelContextSizeFromAPI fetches the context window size from the Ollama API
func getModelContextSizeFromAPI(modelName string, ollamaURL string) (int, error) <span class="cov0" title="0">{
        // Check cache first
        cacheKey := modelName + "@" + ollamaURL
        contextSizeCacheMutex.RLock()
        if size, found := contextSizeCache[cacheKey]; found </span><span class="cov0" title="0">{
                contextSizeCacheMutex.RUnlock()
                return size, nil
        }</span>
        <span class="cov0" title="0">contextSizeCacheMutex.RUnlock()

        // Prepare the API request
        payload := map[string]interface{}{
                "model": modelName,
        }
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Make the API request
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Post(ollamaURL+"/api/show", "application/json", bytes.NewBuffer(payloadBytes))
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("HTTP error: %d", resp.StatusCode)
        }</span>

        // Parse the response
        <span class="cov0" title="0">var response OllamaShowResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Get context length from response
        <span class="cov0" title="0">contextSize := 0
        if response.ModelInfo.ContextLength &gt; 0 </span><span class="cov0" title="0">{
                contextSize = response.ModelInfo.ContextLength
        }</span> else<span class="cov0" title="0"> if response.ModelInfo.GeneralContextLength &gt; 0 </span><span class="cov0" title="0">{
                contextSize = response.ModelInfo.GeneralContextLength
        }</span> else<span class="cov0" title="0"> {
                return 0, fmt.Errorf("no context length found in model info")
        }</span>

        // Cache the result
        <span class="cov0" title="0">if contextSize &gt; 0 </span><span class="cov0" title="0">{
                contextSizeCacheMutex.Lock()
                contextSizeCache[cacheKey] = contextSize
                contextSizeCacheMutex.Unlock()
        }</span>

        <span class="cov0" title="0">return contextSize, nil</span>
}

// getFallbackContextSize returns a context size from the hardcoded map or a default value
func getFallbackContextSize(modelName string) int <span class="cov0" title="0">{
        // Check if we have an exact match in our map
        if size, ok := modelContextSizes[modelName]; ok </span><span class="cov0" title="0">{
                return size
        }</span>

        // If not, try to find a partial match by removing version suffixes
        <span class="cov0" title="0">for model, size := range modelContextSizes </span><span class="cov0" title="0">{
                // If the model name contains our model (ignoring versions)
                if strings.Contains(modelName, model) </span><span class="cov0" title="0">{
                        return size
                }</span>
        }

        // If we still don't have a match, try just the base name
        <span class="cov0" title="0">baseName := strings.Split(modelName, ":")[0]
        baseName = strings.Split(baseName, "-")[0]

        for model, size := range modelContextSizes </span><span class="cov0" title="0">{
                if strings.HasPrefix(model, baseName) </span><span class="cov0" title="0">{
                        return size
                }</span>
        }

        // Default to a common context size if we can't determine it
        <span class="cov0" title="0">return 8192</span> // 8K context is a safe default
}

// getModelContextSize returns the context window size for the given model
func (m Model) getModelContextSize(modelName string) int <span class="cov0" title="0">{
        // Try to get context size from the Ollama API first
        if m.config != nil &amp;&amp; m.config.OllamaURL != "" </span><span class="cov0" title="0">{
                size, err := getModelContextSizeFromAPI(modelName, m.config.OllamaURL)
                if err == nil &amp;&amp; size &gt; 0 </span><span class="cov0" title="0">{
                        return size
                }</span>
                // If there's an error or size is 0, fall back to hardcoded values
        }

        // Fall back to hardcoded values
        <span class="cov0" title="0">return getFallbackContextSize(modelName)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package chat

import (
        "github.com/charmbracelet/lipgloss"
)

// Styles holds precomputed styles for the chat UI
type Styles struct {
        // Style for user message headers
        userHeader lipgloss.Style

        // Style for assistant message headers
        assistantHeader lipgloss.Style

        // Style for the message container
        messages lipgloss.Style

        // Style for the empty message state
        emptyMessages lipgloss.Style

        // Style for the status bar
        statusBar lipgloss.Style

        // Style for the system prompt panel
        systemPrompt lipgloss.Style
}

// DefaultStyles creates default styles for the chat UI
func DefaultStyles() Styles <span class="cov0" title="0">{
        return Styles{
                userHeader: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("12")).
                        Bold(true),

                assistantHeader: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("10")).
                        Bold(true),

                messages: lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("#8A7FD8")).
                        Padding(0, 1), // Add horizontal padding for better readability

                emptyMessages: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Align(lipgloss.Center),

                statusBar: lipgloss.NewStyle().
                        Align(lipgloss.Left).
                        Foreground(lipgloss.Color("240")).
                        PaddingLeft(1),

                systemPrompt: lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("13")). // Purple border for distinction
                        Padding(1, 1).
                        Foreground(lipgloss.Color("15")), // Normal white text, no background
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package chat

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// getSystemPromptHeight calculates the height of the system prompt panel
func (m Model) getSystemPromptHeight() int <span class="cov0" title="0">{
        if !m.showSystemPrompt </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var systemPrompt string
        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                systemPrompt = m.systemPromptEditor
        }</span> else<span class="cov0" title="0"> {
                systemPrompt = m.sessionSystemPrompt
        }</span>

        // Estimate system prompt height based on content and borders
        <span class="cov0" title="0">lines := m.wrapText(systemPrompt, m.width-4) // Account for borders

        // Calculate the height but make sure it doesn't exceed a reasonable size
        // Add 4 for the borders, header, and padding, plus 1 for top margin
        promptHeight := len(lines) + 4 + 1

        // Limit the system prompt height to a maximum of 1/3 of the screen height
        // to ensure it doesn't take too much space
        maxHeight := m.height / 3
        if promptHeight &gt; maxHeight </span><span class="cov0" title="0">{
                promptHeight = maxHeight
        }</span>

        <span class="cov0" title="0">return promptHeight</span>
}

// renderSystemPrompt renders the system prompt panel
func (m Model) renderSystemPrompt() string <span class="cov0" title="0">{
        if !m.showSystemPrompt </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var systemPrompt string
        var header string

        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                // Edit mode - show editable content
                systemPrompt = m.systemPromptEditor
                header = "System Prompt - EDITING (ctrl+s to save, ctrl+r to restore default)"
        }</span> else<span class="cov0" title="0"> {
                // Display mode - show current session prompt
                systemPrompt = m.sessionSystemPrompt
                header = "System Prompt (ctrl+s to close, ctrl+e to edit)"
        }</span>

        // Apply the style and wrap text to fit
        <span class="cov0" title="0">width := m.width - 4 // Account for borders and padding

        // Handle empty system prompt
        if strings.TrimSpace(systemPrompt) == "" </span><span class="cov0" title="0">{
                if m.systemPromptEditMode </span><span class="cov0" title="0">{
                        systemPrompt = ""
                }</span> else<span class="cov0" title="0"> {
                        systemPrompt = "No system prompt configured."
                }</span>
        }

        // Wrap the text and limit its height
        <span class="cov0" title="0">wrappedLines := m.wrapText(systemPrompt, width)

        // Determine maximum content lines based on height constraints
        // (total height - header lines - padding)
        maxPromptHeight := m.getSystemPromptHeight() - 4
        if len(wrappedLines) &gt; maxPromptHeight </span><span class="cov0" title="0">{
                // If text is too long, truncate and add an ellipsis
                wrappedLines = wrappedLines[:maxPromptHeight]
                if !m.systemPromptEditMode </span><span class="cov0" title="0">{
                        wrappedLines[maxPromptHeight-1] += "..."
                }</span>
        }
        <span class="cov0" title="0">wrappedText := strings.Join(wrappedLines, "\n")

        // Create a header and content
        content := fmt.Sprintf("%s\n\n%s", header, wrappedText)

        // Apply different styling based on edit mode
        style := m.styles.systemPrompt.Width(m.width - 2).MarginTop(1)
        if m.systemPromptEditMode </span><span class="cov0" title="0">{
                // Add a visual indicator for edit mode (different border color)
                style = style.BorderForeground(lipgloss.Color("#FFD700")) // Gold color for edit mode
        }</span>

        <span class="cov0" title="0">return style.Render(content)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package chat

import (
        "strings"
        "unicode"
)

// updateTokenCount calculates the estimated token count for the current conversation
func (m *Model) updateTokenCount() <span class="cov0" title="0">{
        var totalText string

        // Include system prompt if configured
        if m.sessionSystemPrompt != "" </span><span class="cov0" title="0">{
                totalText += m.sessionSystemPrompt + " "
        }</span>

        // Combine all message content
        <span class="cov0" title="0">for _, msg := range m.messages </span><span class="cov0" title="0">{
                totalText += msg.Content + " "
        }</span>

        // Add current input if any
        <span class="cov0" title="0">if m.inputModel != nil &amp;&amp; len(m.inputModel.Value()) &gt; 0 </span><span class="cov0" title="0">{
                totalText += m.inputModel.Value()
        }</span>

        // Estimate tokens using our own estimator
        <span class="cov0" title="0">m.tokenCount = estimateTokens(totalText)</span>
}

// estimateTokens provides a rough estimate of GPT-style tokens
func estimateTokens(text string) int <span class="cov8" title="1">{
        // A very rough approximation: English text averages ~4 characters per token in GPT models
        const avgCharsPerToken = 4

        // Count characters excluding whitespace
        charCount := 0
        for _, char := range text </span><span class="cov8" title="1">{
                if !unicode.IsSpace(char) </span><span class="cov8" title="1">{
                        charCount++
                }</span>
        }

        // Add a small constant to account for spaces between words
        <span class="cov8" title="1">wordCount := len(strings.Fields(text))

        // Estimate token count
        tokenEstimate := (charCount + wordCount) / avgCharsPerToken
        if tokenEstimate &lt; 1 &amp;&amp; len(strings.TrimSpace(text)) &gt; 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov8" title="1">return tokenEstimate</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package configuration

import (
        "fmt"
        "maps"
        "strconv"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/kevensen/gollama-chat/internal/configuration"
        "github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/models"
        "github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/utils/connection"
        ragTab "github.com/kevensen/gollama-chat/internal/tui/tabs/rag"
)

// ConfigUpdatedMsg is sent when the configuration has been updated and saved
type ConfigUpdatedMsg = ragTab.ConfigUpdatedMsg

// Field represents a configuration field being edited
type Field int

const (
        ChatModelField Field = iota
        EmbeddingModelField
        DefaultSystemPromptField
        RAGEnabledField
        OllamaURLField
        ChromaDBURLField
        ChromaDBDistanceField
        MaxDocumentsField
        DarkModeField
)

// Model represents the configuration tab model
type Model struct {
        config         *configuration.Config
        editConfig     *configuration.Config // Copy for editing
        activeField    Field
        editing        bool
        input          string
        cursor         int
        width          int
        height         int
        message        string
        messageStyle   lipgloss.Style
        ollamaStatus   connection.Status
        chromaDBStatus connection.Status
        modelPanel     models.Model
        showModelPanel bool
}

// NewModel creates a new configuration model
func NewModel(config *configuration.Config) Model <span class="cov0" title="0">{
        // Create a copy for editing
        editConfig := &amp;configuration.Config{
                ChatModel:           config.ChatModel,
                EmbeddingModel:      config.EmbeddingModel,
                RAGEnabled:          config.RAGEnabled,
                OllamaURL:           config.OllamaURL,
                ChromaDBURL:         config.ChromaDBURL,
                ChromaDBDistance:    config.ChromaDBDistance,
                MaxDocuments:        config.MaxDocuments,
                DarkMode:            config.DarkMode,
                SelectedCollections: make(map[string]bool),
                DefaultSystemPrompt: config.DefaultSystemPrompt,
        }

        // Copy the selectedCollections map
        maps.Copy(editConfig.SelectedCollections, config.SelectedCollections)

        return Model{
                config:         config,
                editConfig:     editConfig,
                activeField:    OllamaURLField,
                editing:        false,
                ollamaStatus:   connection.StatusUnknown,
                chromaDBStatus: connection.StatusUnknown,
                modelPanel:     models.NewModel(),
                showModelPanel: false,
                messageStyle: lipgloss.NewStyle().
                        Foreground(lipgloss.Color("10")).
                        Bold(true),
        }
}</span>

// Init initializes the configuration model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        // Start checking connections when the model initializes
        return tea.Batch(
                connection.OllamaStatus(m.editConfig.OllamaURL),
                connection.ChromaDBStatus(m.editConfig.ChromaDBURL),
        )
}</span>

// Update handles messages and updates the configuration model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height
                // Update model panel size - allocate about 1/3 of width for the panel
                panelWidth := m.width / 3
                panelHeight := m.height - 10 // Leave room for other UI elements
                m.modelPanel = m.modelPanel.SetSize(panelWidth, panelHeight)</span>

        case connection.CheckMsg:<span class="cov0" title="0">
                switch msg.Server </span>{
                case "ollama":<span class="cov0" title="0">
                        m.ollamaStatus = msg.Status</span>
                case "chromadb":<span class="cov0" title="0">
                        m.chromaDBStatus = msg.Status</span>
                }

        case models.FetchModelsMsg:<span class="cov0" title="0">
                var cmd tea.Cmd
                m.modelPanel, cmd = m.modelPanel.Update(msg)
                return m, cmd</span>

        case models.ModelSelectedMsg:<span class="cov0" title="0">
                // Handle model selection
                switch msg.Mode </span>{
                case models.ChatModelSelection:<span class="cov0" title="0">
                        m.editConfig.ChatModel = msg.ModelName</span>
                case models.EmbeddingModelSelection:<span class="cov0" title="0">
                        m.editConfig.EmbeddingModel = msg.ModelName</span>
                }
                <span class="cov0" title="0">m.showModelPanel = false

                // Auto-save the configuration after model selection
                if saveErr, updateCmd := m.autoSaveConfiguration(); saveErr != nil </span><span class="cov0" title="0">{
                        m.message = fmt.Sprintf("Selected: %s (save failed: %s)", msg.ModelName, saveErr.Error())
                        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("11")) // Yellow for warning
                        return m, nil
                }</span> else<span class="cov0" title="0"> {
                        m.message = fmt.Sprintf("Selected and saved: %s", msg.ModelName)
                        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("10"))
                        return m, updateCmd
                }</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                if m.editing </span><span class="cov0" title="0">{
                        return m.handleEditingKeys(msg)
                }</span> else<span class="cov0" title="0"> {
                        return m.handleNavigationKeys(msg)
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleNavigationKeys handles keys when not editing a field
func (m Model) handleNavigationKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // If model panel is visible, forward keys to it first
        if m.showModelPanel </span><span class="cov0" title="0">{
                switch msg.String() </span>{
                case "esc":<span class="cov0" title="0">
                        // Close model panel
                        m.showModelPanel = false
                        return m, nil</span>
                default:<span class="cov0" title="0">
                        // Forward to model panel
                        var cmd tea.Cmd
                        m.modelPanel, cmd = m.modelPanel.Update(msg)
                        return m, cmd</span>
                }
        }

        <span class="cov0" title="0">switch msg.String() </span>{
        case "up", "k":<span class="cov0" title="0">
                if m.activeField &gt; 0 </span><span class="cov0" title="0">{
                        m.activeField--
                }</span>

        case "down", "j":<span class="cov0" title="0">
                if m.activeField &lt; DarkModeField </span><span class="cov0" title="0">{ // Updated to use actual last field
                        m.activeField++
                }</span>

        case "enter", " ":<span class="cov0" title="0">
                // Check if we should show model selection panel
                if m.activeField == ChatModelField || m.activeField == EmbeddingModelField </span><span class="cov0" title="0">{
                        if m.ollamaStatus == connection.StatusConnected </span><span class="cov0" title="0">{
                                var mode models.SelectionMode
                                if m.activeField == ChatModelField </span><span class="cov0" title="0">{
                                        mode = models.ChatModelSelection
                                }</span> else<span class="cov0" title="0"> {
                                        mode = models.EmbeddingModelSelection
                                }</span>

                                <span class="cov0" title="0">m.modelPanel = m.modelPanel.SetVisible(true, mode)
                                m.showModelPanel = true

                                // Fetch models from Ollama
                                return m, models.FetchModels(m.editConfig.OllamaURL)</span>
                        } else<span class="cov0" title="0"> {
                                m.message = "Cannot fetch models: Ollama server not connected"
                                m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("9"))
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Start editing the active field
                        m.editing = true
                        m.input = m.getCurrentFieldValue()
                        m.cursor = len(m.input)
                }</span>

        case "s", "S":<span class="cov0" title="0">
                // Save configuration
                return m.saveConfiguration()</span>

        case "r", "R":<span class="cov0" title="0">
                // Reset to defaults
                m.editConfig = configuration.DefaultConfig()

                // Auto-save the default configuration
                if saveErr, updateCmd := m.autoSaveConfiguration(); saveErr != nil </span><span class="cov0" title="0">{
                        m.message = fmt.Sprintf("Configuration reset to defaults (save failed: %s)", saveErr.Error())
                        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("11")) // Yellow for warning
                        return m, nil
                }</span> else<span class="cov0" title="0"> {
                        m.message = "Configuration reset to defaults and saved"
                        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("11"))
                        return m, updateCmd
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// handleEditingKeys handles keys when editing a field
func (m Model) handleEditingKeys(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "enter":<span class="cov0" title="0">
                // Save the field value
                if err := m.setCurrentFieldValue(m.input); err != nil </span><span class="cov0" title="0">{
                        m.message = fmt.Sprintf("Error: %s", err.Error())
                        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("9"))
                }</span> else<span class="cov0" title="0"> {
                        // Auto-save the configuration after successful field update
                        saveErr, updateCmd := m.autoSaveConfiguration()
                        if saveErr != nil </span><span class="cov0" title="0">{
                                m.message = fmt.Sprintf("Field updated but save failed: %s", saveErr.Error())
                                m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("11")) // Yellow for warning
                                m.editing = false
                                return m, nil
                        }</span> else<span class="cov0" title="0"> {
                                m.message = "Field updated and saved"
                                m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("10"))
                        }</span>

                        // Check if we need to re-test connections
                        <span class="cov0" title="0">var cmd tea.Cmd
                        var cmds []tea.Cmd

                        // Add the config update command
                        cmds = append(cmds, updateCmd)

                        switch m.activeField </span>{
                        case OllamaURLField:<span class="cov0" title="0">
                                m.ollamaStatus = connection.StatusChecking
                                cmd = connection.OllamaStatus(m.editConfig.OllamaURL)</span>
                        case ChromaDBURLField:<span class="cov0" title="0">
                                m.chromaDBStatus = connection.StatusChecking
                                cmd = connection.ChromaDBStatus(m.editConfig.ChromaDBURL)</span>
                        }

                        // Add the connection check command if there is one
                        <span class="cov0" title="0">if cmd != nil </span><span class="cov0" title="0">{
                                cmds = append(cmds, cmd)
                        }</span>

                        <span class="cov0" title="0">m.editing = false
                        m.input = ""
                        return m, tea.Batch(cmds...)</span>
                }
                <span class="cov0" title="0">m.editing = false
                m.input = ""</span>

        case "esc":<span class="cov0" title="0">
                // Cancel editing
                m.editing = false
                m.input = ""</span>

        case "backspace":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.input = m.input[:m.cursor-1] + m.input[m.cursor:]
                        m.cursor--
                }</span>

        case "left":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.cursor--
                }</span>

        case "right":<span class="cov0" title="0">
                if m.cursor &lt; len(m.input) </span><span class="cov0" title="0">{
                        m.cursor++
                }</span>

        case "home":<span class="cov0" title="0">
                m.cursor = 0</span>

        case "end":<span class="cov0" title="0">
                m.cursor = len(m.input)</span>

        default:<span class="cov0" title="0">
                // Add character to input
                if len(msg.String()) == 1 </span><span class="cov0" title="0">{
                        m.input = m.input[:m.cursor] + msg.String() + m.input[m.cursor:]
                        m.cursor++
                }</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the configuration tab
func (m Model) View() string <span class="cov0" title="0">{
        if m.width == 0 || m.height == 0 </span><span class="cov0" title="0">{
                return "Loading..."
        }</span>

        // If model panel is visible, show side-by-side layout
        <span class="cov0" title="0">if m.showModelPanel </span><span class="cov0" title="0">{
                return m.renderSideBySideView()
        }</span>

        // Regular single-panel view
        <span class="cov0" title="0">return m.renderConfigurationView()</span>
}

// renderSideBySideView renders configuration and model panel side by side
func (m Model) renderSideBySideView() string <span class="cov0" title="0">{
        // Allocate 2/3 width to config, 1/3 to model panel
        configWidth := (m.width * 2) / 3

        // Render configuration view with reduced width
        configView := m.renderConfigurationViewWithWidth(configWidth)

        // Render model panel
        modelPanelView := m.modelPanel.View()

        // Combine side by side
        return lipgloss.JoinHorizontal(lipgloss.Top, configView, modelPanelView)
}</span>

// renderConfigurationView renders the full-width configuration view
func (m Model) renderConfigurationView() string <span class="cov0" title="0">{
        return m.renderConfigurationViewWithWidth(m.width)
}</span>

// renderConfigurationViewWithWidth renders the configuration view with specified width
func (m Model) renderConfigurationViewWithWidth(width int) string <span class="cov0" title="0">{
        var content []string

        // Title
        titleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("12")).
                Bold(true).
                Align(lipgloss.Center).
                Width(width - 2)

        content = append(content, titleStyle.Render("Configuration Settings"))
        content = append(content, "")

        // Configuration fields
        fields := []struct {
                field Field
                label string
                value string
                help  string
        }{
                {ChatModelField, "Chat Model", m.editConfig.ChatModel, "Model used for chat conversations (Enter: Select from list)"},
                {EmbeddingModelField, "Embedding Model", m.editConfig.EmbeddingModel, "Model for embeddings (Enter: Select from list)"},
                {DefaultSystemPromptField, "Default System Prompt", m.editConfig.DefaultSystemPrompt, "System prompt sent with each message"},
                {RAGEnabledField, "RAG Enabled", fmt.Sprintf("%t", m.editConfig.RAGEnabled), "Enable Retrieval Augmented Generation"},
                {OllamaURLField, "Ollama URL", m.editConfig.OllamaURL, "URL of the Ollama server"},
                {ChromaDBURLField, "ChromaDB URL", m.editConfig.ChromaDBURL, "URL of the ChromaDB server"},
                {ChromaDBDistanceField, "ChromaDB Distance", fmt.Sprintf("%.2f", m.editConfig.ChromaDBDistance), "Distance threshold for cosine similarity (0-2 range)"},
                {MaxDocumentsField, "Max Documents", fmt.Sprintf("%d", m.editConfig.MaxDocuments), "Maximum documents for RAG"},
                {DarkModeField, "Dark Mode", fmt.Sprintf("%t", m.editConfig.DarkMode), "Enable dark mode theme"},
        }

        for _, field := range fields </span><span class="cov0" title="0">{
                content = append(content, m.renderField(field.field, field.label, field.value, field.help))
                content = append(content, "")
        }</span>

        // Help text
        <span class="cov0" title="0">content = append(content, "")
        helpStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Width(width - 2)
        content = append(content, helpStyle.Render("↑/↓: Navigate • Enter: Edit/Select (auto-saves) • S: Save • R: Reset to defaults"))
        if m.editing </span><span class="cov0" title="0">{
                content = append(content, helpStyle.Render("Enter: Save • Esc: Cancel"))
        }</span>

        <span class="cov0" title="0">if m.showModelPanel </span><span class="cov0" title="0">{
                content = append(content, helpStyle.Render("Model Selection: ↑/↓: Navigate • Enter: Select • Esc: Cancel"))
        }</span>
        // Message
        <span class="cov0" title="0">if m.message != "" </span><span class="cov0" title="0">{
                content = append(content, "")
                content = append(content, m.messageStyle.Render(m.message))
        }</span>

        // Container - calculate height like main TUI does for content area
        <span class="cov0" title="0">tabBarHeight := 1
        footerHeight := 1
        contentHeight := m.height - tabBarHeight - footerHeight
        if contentHeight &lt; 1 </span><span class="cov0" title="0">{
                contentHeight = 1
        }</span>

        <span class="cov0" title="0">containerStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("#8A7FD8")).
                Padding(1, 2).
                Width(width - 2).
                Height(contentHeight) // Match main TUI's content height calculation

        return containerStyle.Render(strings.Join(content, "\n"))</span>
}

// renderField renders a configuration field
func (m Model) renderField(field Field, label, value, help string) string <span class="cov0" title="0">{
        isActive := field == m.activeField
        isEditing := m.editing &amp;&amp; isActive

        labelStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("7"))
        valueStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("15"))
        if isActive </span><span class="cov0" title="0">{
                labelStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("12")).
                        Bold(true)
                valueStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("15")).
                        Background(lipgloss.Color("62"))
        }</span>

        // Display value with cursor if editing
        <span class="cov0" title="0">displayValue := value
        if isEditing </span><span class="cov0" title="0">{
                displayValue = m.input
                if m.cursor &lt;= len(displayValue) </span><span class="cov0" title="0">{
                        if m.cursor == len(displayValue) </span><span class="cov0" title="0">{
                                displayValue += "█"
                        }</span> else<span class="cov0" title="0"> {
                                displayValue = displayValue[:m.cursor] + "█" + displayValue[m.cursor+1:]
                        }</span>
                }
        }

        // Add connectivity status for URL fields
        <span class="cov0" title="0">var statusIndicator string
        switch field </span>{
        case OllamaURLField:<span class="cov0" title="0">
                statusIndicator = m.formatInlineConnectionStatus(m.ollamaStatus)</span>
        case ChromaDBURLField:<span class="cov0" title="0">
                statusIndicator = m.formatInlineConnectionStatus(m.chromaDBStatus)</span>
        }

        // Format the field with status indicator if applicable
        <span class="cov0" title="0">fieldLine := fmt.Sprintf("%s: %s", labelStyle.Render(label), valueStyle.Render(displayValue))
        if statusIndicator != "" </span><span class="cov0" title="0">{
                fieldLine = fmt.Sprintf("%s: %s %s", labelStyle.Render(label), valueStyle.Render(displayValue), statusIndicator)
        }</span>

        <span class="cov0" title="0">if isActive </span><span class="cov0" title="0">{
                helpStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Italic(true)
                return fieldLine + "\n" + helpStyle.Render("  "+help)
        }</span>

        <span class="cov0" title="0">return fieldLine</span>
}

// formatInlineConnectionStatus formats a connection status for inline display
func (m Model) formatInlineConnectionStatus(status connection.Status) string <span class="cov0" title="0">{
        var statusText, statusColor string

        switch status </span>{
        case connection.StatusConnected:<span class="cov0" title="0">
                statusText = "✓"
                statusColor = "10"</span> // Green
        case connection.StatusDisconnected:<span class="cov0" title="0">
                statusText = "✗"
                statusColor = "9"</span> // Red
        case connection.StatusChecking:<span class="cov0" title="0">
                statusText = "⟳"
                statusColor = "11"</span> // Yellow
        default:<span class="cov0" title="0">
                statusText = "?"
                statusColor = "240"</span> // Gray
        }

        <span class="cov0" title="0">statusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(statusColor))
        return statusStyle.Render(statusText)</span>
}

// getCurrentFieldValue gets the current value of the active field
func (m Model) getCurrentFieldValue() string <span class="cov0" title="0">{
        switch m.activeField </span>{
        case ChatModelField:<span class="cov0" title="0">
                return m.editConfig.ChatModel</span>
        case EmbeddingModelField:<span class="cov0" title="0">
                return m.editConfig.EmbeddingModel</span>
        case RAGEnabledField:<span class="cov0" title="0">
                return fmt.Sprintf("%t", m.editConfig.RAGEnabled)</span>
        case OllamaURLField:<span class="cov0" title="0">
                return m.editConfig.OllamaURL</span>
        case ChromaDBURLField:<span class="cov0" title="0">
                return m.editConfig.ChromaDBURL</span>
        case ChromaDBDistanceField:<span class="cov0" title="0">
                return fmt.Sprintf("%.2f", m.editConfig.ChromaDBDistance)</span>
        case MaxDocumentsField:<span class="cov0" title="0">
                return fmt.Sprintf("%d", m.editConfig.MaxDocuments)</span>
        case DarkModeField:<span class="cov0" title="0">
                return fmt.Sprintf("%t", m.editConfig.DarkMode)</span>
        case DefaultSystemPromptField:<span class="cov0" title="0">
                return m.editConfig.DefaultSystemPrompt</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// setCurrentFieldValue sets the current value of the active field
func (m Model) setCurrentFieldValue(value string) error <span class="cov0" title="0">{
        switch m.activeField </span>{
        case ChatModelField:<span class="cov0" title="0">
                if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Chat model cannot be empty")
                }</span>
                <span class="cov0" title="0">m.editConfig.ChatModel = strings.TrimSpace(value)</span>

        case EmbeddingModelField:<span class="cov0" title="0">
                if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Embedding model cannot be empty")
                }</span>
                <span class="cov0" title="0">m.editConfig.EmbeddingModel = strings.TrimSpace(value)</span>

        case RAGEnabledField:<span class="cov0" title="0">
                ragEnabled, err := strconv.ParseBool(strings.TrimSpace(value))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("RAG enabled must be true or false")
                }</span>
                <span class="cov0" title="0">m.editConfig.RAGEnabled = ragEnabled</span>

        case OllamaURLField:<span class="cov0" title="0">
                if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("Ollama URL cannot be empty")
                }</span>
                <span class="cov0" title="0">m.editConfig.OllamaURL = strings.TrimSpace(value)</span>

        case ChromaDBURLField:<span class="cov0" title="0">
                if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("ChromaDB URL cannot be empty")
                }</span>
                <span class="cov0" title="0">m.editConfig.ChromaDBURL = strings.TrimSpace(value)</span>

        case ChromaDBDistanceField:<span class="cov0" title="0">
                distance, err := strconv.ParseFloat(strings.TrimSpace(value), 64)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ChromaDB distance must be a number")
                }</span>
                <span class="cov0" title="0">if distance &lt; 0 || distance &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ChromaDB distance must be between 0.0 and 1.0")
                }</span>
                <span class="cov0" title="0">m.editConfig.ChromaDBDistance = distance</span>

        case MaxDocumentsField:<span class="cov0" title="0">
                maxDocs, err := strconv.Atoi(strings.TrimSpace(value))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Max documents must be a number")
                }</span>
                <span class="cov0" title="0">if maxDocs &lt;= 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("Max documents must be greater than 0")
                }</span>
                <span class="cov0" title="0">m.editConfig.MaxDocuments = maxDocs</span>

        case DarkModeField:<span class="cov0" title="0">
                darkMode, err := strconv.ParseBool(strings.TrimSpace(value))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Dark mode must be true or false")
                }</span>
                <span class="cov0" title="0">m.editConfig.DarkMode = darkMode</span>

        case DefaultSystemPromptField:<span class="cov0" title="0">
                // Allow empty system prompt, but trim whitespace
                m.editConfig.DefaultSystemPrompt = strings.TrimSpace(value)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// saveConfiguration saves the configuration to disk
func (m Model) saveConfiguration() (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        if err := m.editConfig.Validate(); err != nil </span><span class="cov0" title="0">{
                m.message = fmt.Sprintf("Validation error: %s", err.Error())
                m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("9"))
                return m, nil
        }</span>

        <span class="cov0" title="0">if err := m.editConfig.Save(); err != nil </span><span class="cov0" title="0">{
                m.message = fmt.Sprintf("Save error: %s", err.Error())
                m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("9"))
                return m, nil
        }</span>

        // Update the main config
        <span class="cov0" title="0">*m.config = *m.editConfig

        m.message = "Configuration saved successfully!"
        m.messageStyle = m.messageStyle.Foreground(lipgloss.Color("10"))

        // Send configuration update message to notify other tabs
        configUpdateCmd := func() tea.Msg </span><span class="cov0" title="0">{
                return ConfigUpdatedMsg{Config: m.config}
        }</span>

        <span class="cov0" title="0">return m, configUpdateCmd</span>
}

// autoSaveConfiguration automatically saves the configuration to disk after validation
// Returns an error if save fails, nil if successful, and a command to send the config update message
func (m *Model) autoSaveConfiguration() (error, tea.Cmd) <span class="cov0" title="0">{
        if err := m.editConfig.Validate(); err != nil </span><span class="cov0" title="0">{
                return err, nil
        }</span>

        <span class="cov0" title="0">if err := m.editConfig.Save(); err != nil </span><span class="cov0" title="0">{
                return err, nil
        }</span>

        // Update the main config
        <span class="cov0" title="0">*m.config = *m.editConfig

        // Create command to send configuration update message
        configUpdateCmd := func() tea.Msg </span><span class="cov0" title="0">{
                return ConfigUpdatedMsg{Config: m.config}
        }</span>

        <span class="cov0" title="0">return nil, configUpdateCmd</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// OllamaModel represents a model from the Ollama API
type OllamaModel struct {
        Name       string                 `json:"name"`
        ModifiedAt string                 `json:"modified_at"`
        Size       int64                  `json:"size"`
        Digest     string                 `json:"digest"`
        Details    map[string]interface{} `json:"details"`
}

// OllamaModelsResponse represents the response from /api/tags
type OllamaModelsResponse struct {
        Models []OllamaModel `json:"models"`
}

// FetchModelsMsg represents the result of fetching models
type FetchModelsMsg struct {
        Models []OllamaModel
        Error  error
}

// SelectionMode represents whether we're selecting chat or embedding models
type SelectionMode int

const (
        ChatModelSelection SelectionMode = iota
        EmbeddingModelSelection
)

// Model represents the model selection panel
type Model struct {
        models         []OllamaModel
        filteredModels []OllamaModel
        cursor         int
        viewport       int
        height         int
        width          int
        loading        bool
        error          error
        mode           SelectionMode
        filter         string
        visible        bool
}

// NewModel creates a new model selection panel
func NewModel() Model <span class="cov0" title="0">{
        return Model{
                models:         []OllamaModel{},
                filteredModels: []OllamaModel{},
                cursor:         0,
                viewport:       0,
                height:         10,
                loading:        false,
                visible:        false,
        }
}</span>

// Init initializes the model selection panel
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

// SetVisible sets the visibility and mode of the model selection panel
func (m Model) SetVisible(visible bool, mode SelectionMode) Model <span class="cov0" title="0">{
        m.visible = visible
        m.mode = mode
        m.cursor = 0
        m.viewport = 0
        return m
}</span>

// SetSize sets the dimensions of the model selection panel
func (m Model) SetSize(width, height int) Model <span class="cov0" title="0">{
        m.width = width
        m.height = height
        return m
}</span>

// FetchModels fetches available models from Ollama
func FetchModels(ollamaURL string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                client := &amp;http.Client{Timeout: 10 * time.Second}
                resp, err := client.Get(ollamaURL + "/api/tags")
                if err != nil </span><span class="cov0" title="0">{
                        return FetchModelsMsg{
                                Models: nil,
                                Error:  err,
                        }
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        return FetchModelsMsg{
                                Models: nil,
                                Error:  fmt.Errorf("HTTP %d", resp.StatusCode),
                        }
                }</span>

                <span class="cov0" title="0">var response OllamaModelsResponse
                if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                        return FetchModelsMsg{
                                Models: nil,
                                Error:  err,
                        }
                }</span>

                <span class="cov0" title="0">return FetchModelsMsg{
                        Models: response.Models,
                        Error:  nil,
                }</span>
        })
}

// Update handles messages for the model selection panel
func (m Model) Update(msg tea.Msg) (Model, tea.Cmd) <span class="cov0" title="0">{
        if !m.visible </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case FetchModelsMsg:<span class="cov0" title="0">
                m.loading = false
                if msg.Error != nil </span><span class="cov0" title="0">{
                        m.error = msg.Error
                        m.models = []OllamaModel{}
                }</span> else<span class="cov0" title="0"> {
                        m.error = nil
                        m.models = msg.Models
                }</span>
                <span class="cov0" title="0">m.filteredModels = m.filterModels(m.models)
                m.cursor = 0
                m.viewport = 0</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "up":<span class="cov0" title="0">
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                                if m.cursor &lt; m.viewport </span><span class="cov0" title="0">{
                                        m.viewport = m.cursor
                                }</span>
                        }

                case "down":<span class="cov0" title="0">
                        if m.cursor &lt; len(m.filteredModels)-1 </span><span class="cov0" title="0">{
                                m.cursor++
                                if m.cursor &gt;= m.viewport+m.height-2 </span><span class="cov0" title="0">{
                                        m.viewport = m.cursor - m.height + 3
                                }</span>
                        }

                case "enter":<span class="cov0" title="0">
                        if len(m.filteredModels) &gt; 0 </span><span class="cov0" title="0">{
                                selectedModel := m.filteredModels[m.cursor]
                                return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                        return ModelSelectedMsg{
                                                ModelName: selectedModel.Name,
                                                Mode:      m.mode,
                                        }
                                }</span>)
                        }
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

// ModelSelectedMsg represents a model selection event
type ModelSelectedMsg struct {
        ModelName string
        Mode      SelectionMode
}

// filterModels filters models based on the current mode and filter text
func (m Model) filterModels(models []OllamaModel) []OllamaModel <span class="cov0" title="0">{
        var filtered []OllamaModel

        for _, model := range models </span><span class="cov0" title="0">{
                // Apply text filter if any
                if m.filter != "" &amp;&amp; !strings.Contains(strings.ToLower(model.Name), strings.ToLower(m.filter)) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Apply mode-specific filtering
                <span class="cov0" title="0">switch m.mode </span>{
                case EmbeddingModelSelection:<span class="cov0" title="0">
                        // Filter for embedding models (usually contain "embed" in the name)
                        if strings.Contains(strings.ToLower(model.Name), "embed") </span><span class="cov0" title="0">{
                                filtered = append(filtered, model)
                        }</span>
                default:<span class="cov0" title="0">
                        // Chat models - include all non-embedding models
                        if !strings.Contains(strings.ToLower(model.Name), "embed") </span><span class="cov0" title="0">{
                                filtered = append(filtered, model)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// View renders the model selection panel
func (m Model) View() string <span class="cov0" title="0">{
        if !m.visible </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var content []string

        // Title based on mode
        var title string
        switch m.mode </span>{
        case ChatModelSelection:<span class="cov0" title="0">
                title = "Select Chat Model"</span>
        case EmbeddingModelSelection:<span class="cov0" title="0">
                title = "Select Embedding Model"</span>
        }

        <span class="cov0" title="0">titleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("12")).
                Bold(true).
                Align(lipgloss.Center)

        content = append(content, titleStyle.Render(title))
        content = append(content, "")

        // Handle different states
        if m.loading </span><span class="cov0" title="0">{
                loadingStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("11")).
                        Italic(true)
                content = append(content, loadingStyle.Render("⟳ Loading models..."))
        }</span> else<span class="cov0" title="0"> if m.error != nil </span><span class="cov0" title="0">{
                errorStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("9")).
                        Bold(true)
                content = append(content, errorStyle.Render("✗ Error: "+m.error.Error()))
                content = append(content, "")
                content = append(content, "Check Ollama connection and try again.")
        }</span> else<span class="cov0" title="0"> if len(m.filteredModels) == 0 </span><span class="cov0" title="0">{
                noModelsStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("240")).
                        Italic(true)
                content = append(content, noModelsStyle.Render("No models available"))
        }</span> else<span class="cov0" title="0"> {
                // Show models
                start := m.viewport
                end := start + m.height - 2
                if end &gt; len(m.filteredModels) </span><span class="cov0" title="0">{
                        end = len(m.filteredModels)
                }</span>

                <span class="cov0" title="0">for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                        model := m.filteredModels[i]
                        var style lipgloss.Style

                        if i == m.cursor </span><span class="cov0" title="0">{
                                // Selected model
                                style = lipgloss.NewStyle().
                                        Foreground(lipgloss.Color("15")).
                                        Background(lipgloss.Color("62")).
                                        Bold(true)
                        }</span> else<span class="cov0" title="0"> {
                                // Regular model
                                style = lipgloss.NewStyle().
                                        Foreground(lipgloss.Color("7"))
                        }</span>

                        // Format model name and size
                        <span class="cov0" title="0">sizeStr := formatSize(model.Size)
                        modelLine := fmt.Sprintf("  %s (%s)", model.Name, sizeStr)
                        content = append(content, style.Render(modelLine))</span>
                }

                // Show scroll indicator if needed
                <span class="cov0" title="0">if len(m.filteredModels) &gt; m.height-2 </span><span class="cov0" title="0">{
                        scrollInfo := fmt.Sprintf("(%d/%d)", m.cursor+1, len(m.filteredModels))
                        scrollStyle := lipgloss.NewStyle().
                                Foreground(lipgloss.Color("240")).
                                Align(lipgloss.Right)
                        content = append(content, "")
                        content = append(content, scrollStyle.Render(scrollInfo))
                }</span>
        }

        // Help text
        <span class="cov0" title="0">content = append(content, "")
        helpStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Italic(true)
        content = append(content, helpStyle.Render("↑/↓: Navigate • Enter: Select • Esc: Cancel"))

        // Apply border and styling
        panelStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("62")).
                Padding(1, 1).
                Width(m.width - 2).
                Height(m.height)

        return panelStyle.Render(strings.Join(content, "\n"))</span>
}

// formatSize formats a byte size into a human-readable string
func formatSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package connection

import (
        "fmt"
        "net/http"
        "time"

        tea "github.com/charmbracelet/bubbletea"
)

// Status represents the status of a server connection
type Status int

const (
        StatusUnknown Status = iota
        StatusConnected
        StatusDisconnected
        StatusChecking
)

// CheckMsg represents the result of a connection check
type CheckMsg struct {
        Server string
        Status Status
        Error  error
}

// OllamaStatus checks if the Ollama server is reachable
func OllamaStatus(url string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                client := &amp;http.Client{Timeout: 5 * time.Second}
                resp, err := client.Get(url + "/api/tags")
                if err != nil </span><span class="cov0" title="0">{
                        return CheckMsg{
                                Server: "ollama",
                                Status: StatusDisconnected,
                                Error:  err,
                        }
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        return CheckMsg{
                                Server: "ollama",
                                Status: StatusConnected,
                                Error:  nil,
                        }
                }</span>

                <span class="cov0" title="0">return CheckMsg{
                        Server: "ollama",
                        Status: StatusDisconnected,
                        Error:  fmt.Errorf("HTTP %d", resp.StatusCode),
                }</span>
        })
}

// ChromaDBStatus checks if the ChromaDB server is reachable
func ChromaDBStatus(url string) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                client := &amp;http.Client{Timeout: 5 * time.Second}
                resp, err := client.Get(url + "/api/v2")
                if err != nil </span><span class="cov0" title="0">{
                        return CheckMsg{
                                Server: "chromadb",
                                Status: StatusDisconnected,
                                Error:  err,
                        }
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        return CheckMsg{
                                Server: "chromadb",
                                Status: StatusConnected,
                                Error:  nil,
                        }
                }</span>

                <span class="cov0" title="0">return CheckMsg{
                        Server: "chromadb",
                        Status: StatusDisconnected,
                        Error:  fmt.Errorf("HTTP %d", resp.StatusCode),
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rag

import (
        "context"
        "fmt"
        "net/http"
        "time"

        v2 "github.com/amikos-tech/chroma-go/pkg/api/v2"
        "github.com/kevensen/gollama-chat/internal/configuration"
)

// Collection represents a ChromaDB collection with selection state
type Collection struct {
        Name     string            `json:"name"`
        ID       string            `json:"id"`
        Metadata map[string]string `json:"metadata"`
        Selected bool              `json:"selected"`
}

// CollectionsService handles ChromaDB collections operations
type CollectionsService struct {
        Config      *configuration.Config
        client      v2.Client
        collections []Collection
        connected   bool
}

// NewCollectionsService creates a new collections service
func NewCollectionsService(config *configuration.Config) *CollectionsService <span class="cov0" title="0">{
        return &amp;CollectionsService{
                Config:      config,
                collections: make([]Collection, 0),
                connected:   false,
        }
}</span>

// TestConnection tests the ChromaDB connection
func (cs *CollectionsService) TestConnection() error <span class="cov0" title="0">{
        if cs.Config.ChromaDBURL == "" </span><span class="cov0" title="0">{
                cs.connected = false
                return fmt.Errorf("ChromaDB URL not configured")
        }</span>

        // Use the same approach as the settings tab - simple HTTP GET to /api/v2
        <span class="cov0" title="0">client := &amp;http.Client{Timeout: 5 * time.Second}
        resp, err := client.Get(cs.Config.ChromaDBURL + "/api/v2")
        if err != nil </span><span class="cov0" title="0">{
                cs.connected = false
                return fmt.Errorf("failed to connect to ChromaDB: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                cs.connected = false
                return fmt.Errorf("ChromaDB returned HTTP %d", resp.StatusCode)
        }</span>

        // If basic connection works, try to create the full client for later use
        <span class="cov0" title="0">chromaClient, err := v2.NewHTTPClient(v2.WithBaseURL(cs.Config.ChromaDBURL))
        if err != nil </span><span class="cov0" title="0">{
                cs.connected = false
                return fmt.Errorf("failed to create ChromaDB client: %w", err)
        }</span>

        <span class="cov0" title="0">cs.client = chromaClient
        cs.connected = true
        return nil</span>
}

// LoadCollections loads collections from ChromaDB
func (cs *CollectionsService) LoadCollections(ctx context.Context) error <span class="cov0" title="0">{
        if !cs.connected || cs.client == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected to ChromaDB")
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        chromaCollections, err := cs.client.ListCollections(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list collections: %w", err)
        }</span>

        // Convert to our Collection format and select all by default
        <span class="cov0" title="0">cs.collections = make([]Collection, len(chromaCollections))
        for i, collection := range chromaCollections </span><span class="cov0" title="0">{
                // Convert metadata from chroma-go format to our expected format
                metadataMap := make(map[string]string)
                if metadata := collection.Metadata(); metadata != nil </span><span class="cov0" title="0">{
                        for _, key := range metadata.Keys() </span><span class="cov0" title="0">{
                                if strValue, ok := metadata.GetString(key); ok </span><span class="cov0" title="0">{
                                        metadataMap[key] = strValue
                                }</span> else<span class="cov0" title="0"> if rawValue, ok := metadata.GetRaw(key); ok </span><span class="cov0" title="0">{
                                        metadataMap[key] = fmt.Sprintf("%v", rawValue)
                                }</span>
                        }
                }

                <span class="cov0" title="0">cs.collections[i] = Collection{
                        Name:     collection.Name(),
                        ID:       collection.ID(),
                        Metadata: metadataMap,
                        Selected: true, // Select all by default as requested
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetCollections returns the list of collections
func (cs *CollectionsService) GetCollections() []Collection <span class="cov0" title="0">{
        return cs.collections
}</span>

// IsConnected returns the connection status
func (cs *CollectionsService) IsConnected() bool <span class="cov0" title="0">{
        return cs.connected
}</span>

// ToggleCollection toggles the selection state of a collection
func (cs *CollectionsService) ToggleCollection(index int) <span class="cov0" title="0">{
        if index &gt;= 0 &amp;&amp; index &lt; len(cs.collections) </span><span class="cov0" title="0">{
                cs.collections[index].Selected = !cs.collections[index].Selected
        }</span>
}

// SelectAll selects all collections
func (cs *CollectionsService) SelectAll() <span class="cov0" title="0">{
        for i := range cs.collections </span><span class="cov0" title="0">{
                cs.collections[i].Selected = true
        }</span>
}

// DeselectAll deselects all collections
func (cs *CollectionsService) DeselectAll() <span class="cov0" title="0">{
        for i := range cs.collections </span><span class="cov0" title="0">{
                cs.collections[i].Selected = false
        }</span>
}

// GetSelectedCollections returns a list of selected collection names
func (cs *CollectionsService) GetSelectedCollections() []string <span class="cov0" title="0">{
        var selected []string
        for _, collection := range cs.collections </span><span class="cov0" title="0">{
                if collection.Selected </span><span class="cov0" title="0">{
                        selected = append(selected, collection.Name)
                }</span>
        }
        <span class="cov0" title="0">return selected</span>
}

// GetSelectedCount returns the number of selected collections
func (cs *CollectionsService) GetSelectedCount() int <span class="cov0" title="0">{
        count := 0
        for _, collection := range cs.collections </span><span class="cov0" title="0">{
                if collection.Selected </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Close closes the ChromaDB client connection
func (cs *CollectionsService) Close() error <span class="cov0" title="0">{
        if cs.client != nil </span><span class="cov0" title="0">{
                return cs.client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package rag

import (
        "context"
        "fmt"
        "strings"

        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/kevensen/gollama-chat/internal/configuration"
)

// Message types for async operations
type collectionsLoadedMsg struct {
        collections []Collection
        err         error
}

type connectionTestMsg struct {
        connected bool
        err       error
}

// ConfigUpdatedMsg is sent when the configuration has been updated
type ConfigUpdatedMsg struct {
        Config *configuration.Config
}

// CollectionsUpdatedMsg is sent when collections selection has changed
type CollectionsUpdatedMsg struct {
        SelectedCollections []string
}

// Model represents the RAG collections tab model
type Model struct {
        config             *configuration.Config
        collectionsService *CollectionsService
        viewport           viewport.Model
        cursor             int
        collections        []Collection
        connected          bool
        loading            bool
        error              string
        width              int
        height             int
        ctx                context.Context
}

// NewModel creates a new RAG collections model
func NewModel(ctx context.Context, config *configuration.Config) Model <span class="cov0" title="0">{
        vp := viewport.New(0, 0)
        vp.YPosition = 0

        return Model{
                config:             config,
                collectionsService: NewCollectionsService(config),
                viewport:           vp,
                cursor:             0,
                collections:        make([]Collection, 0),
                connected:          false,
                loading:            true,
                ctx:                ctx,
        }
}</span>

// Init initializes the model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return m.testConnection()
}</span>

// Update handles messages and updates the model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height

                // Calculate viewport size (leave room for header and footer within the container)
                tabBarHeight := 1
                footerHeight := 1
                contentHeight := m.height - tabBarHeight - footerHeight
                if contentHeight &lt; 1 </span><span class="cov0" title="0">{
                        contentHeight = 1
                }</span>

                <span class="cov0" title="0">headerHeight := 5     // Title + connection status + instructions
                ragFooterHeight := 3  // Selection count + controls
                containerPadding := 4 // Border (2) + padding (2)
                availableHeight := contentHeight - headerHeight - ragFooterHeight - containerPadding
                if availableHeight &lt; 1 </span><span class="cov0" title="0">{
                        availableHeight = 1
                }</span>

                <span class="cov0" title="0">m.viewport.Width = int(float64(m.width) * 0.95)
                m.viewport.Height = availableHeight
                m.updateViewportContent()</span>

        case ConfigUpdatedMsg:<span class="cov0" title="0">
                // Update configuration and refresh connection
                m.config = msg.Config
                m.collectionsService.Config = msg.Config
                m.loading = true
                m.connected = false
                m.error = ""
                m.updateViewportContent()
                // Test connection with new configuration
                return m, m.testConnection()</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // Always allow these debug/control keys, even when loading
                switch msg.String() </span>{
                case "c":<span class="cov0" title="0"> // Show config (debug)
                        m.error = fmt.Sprintf("Debug: ChromaDB URL = '%s', Loading = %t", m.config.ChromaDBURL, m.loading)
                        m.updateViewportContent()
                        return m, nil</span>
                case "u":<span class="cov0" title="0"> // Update/refresh config
                        // Reload configuration from disk
                        if newConfig, err := configuration.Load(); err == nil </span><span class="cov0" title="0">{
                                m.config = newConfig
                                m.collectionsService.Config = newConfig
                                m.error = "Configuration refreshed"
                                m.updateViewportContent()
                        }</span> else<span class="cov0" title="0"> {
                                m.error = fmt.Sprintf("Failed to reload config: %v", err)
                                m.updateViewportContent()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case "t":<span class="cov0" title="0"> // Test connection
                        m.loading = true
                        m.error = ""
                        return m, m.testConnection()</span>
                case "x":<span class="cov0" title="0"> // Force stop loading (emergency)
                        m.loading = false
                        m.error = "Loading cancelled by user"
                        m.updateViewportContent()
                        return m, nil</span>
                }

                // Only handle other keys when not loading
                <span class="cov0" title="0">if m.loading </span><span class="cov0" title="0">{
                        return m, nil
                }</span>

                // Handle navigation and selection keys
                <span class="cov0" title="0">switch msg.String() </span>{
                case "up", "k":<span class="cov0" title="0">
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                                m.updateViewportScroll()
                                m.updateViewportContent()                                              // Add this to refresh the display
                                m.error = fmt.Sprintf("DEBUG: Up pressed, cursor now at %d", m.cursor) // Debug
                        }</span>
                        <span class="cov0" title="0">return m, nil</span> // Prevent viewport from handling this key
                case "down", "j":<span class="cov0" title="0">
                        if m.cursor &lt; len(m.collections)-1 </span><span class="cov0" title="0">{
                                m.cursor++
                                m.updateViewportScroll()
                                m.updateViewportContent()                                                // Add this to refresh the display
                                m.error = fmt.Sprintf("DEBUG: Down pressed, cursor now at %d", m.cursor) // Debug
                        }</span>
                        <span class="cov0" title="0">return m, nil</span> // Prevent viewport from handling this key
                case " ", "enter":<span class="cov0" title="0"> // Toggle selection
                        if len(m.collections) &gt; 0 &amp;&amp; m.cursor &lt; len(m.collections) </span><span class="cov0" title="0">{
                                m.collectionsService.ToggleCollection(m.cursor)
                                m.collections = m.collectionsService.GetCollections()
                                m.updateViewportContent()
                                // Send message to notify about collection changes
                                return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                        return CollectionsUpdatedMsg{
                                                SelectedCollections: m.collectionsService.GetSelectedCollections(),
                                        }
                                }</span>)
                        }
                        <span class="cov0" title="0">return m, nil</span>
                case "ctrl+a":<span class="cov0" title="0"> // Select all
                        m.collectionsService.SelectAll()
                        m.collections = m.collectionsService.GetCollections()
                        m.updateViewportContent()
                        // Send message to notify about collection changes
                        return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                return CollectionsUpdatedMsg{
                                        SelectedCollections: m.collectionsService.GetSelectedCollections(),
                                }
                        }</span>)
                case "ctrl+d":<span class="cov0" title="0"> // Deselect all
                        m.collectionsService.DeselectAll()
                        m.collections = m.collectionsService.GetCollections()
                        m.updateViewportContent()
                        // Send message to notify about collection changes
                        return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                return CollectionsUpdatedMsg{
                                        SelectedCollections: m.collectionsService.GetSelectedCollections(),
                                }
                        }</span>)
                case "r":<span class="cov0" title="0"> // Refresh collections
                        if m.connected </span><span class="cov0" title="0">{
                                m.loading = true
                                return m, m.loadCollections(m.ctx)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                }

        case connectionTestMsg:<span class="cov0" title="0">
                m.loading = false
                m.connected = msg.connected
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.error = fmt.Sprintf("Connection failed: %v", msg.err)
                        m.collections = make([]Collection, 0)
                }</span> else<span class="cov0" title="0"> {
                        m.error = ""
                        if m.connected </span><span class="cov0" title="0">{
                                return m, m.loadCollections(m.ctx)
                        }</span>
                }
                <span class="cov0" title="0">m.updateViewportContent()</span>

        case collectionsLoadedMsg:<span class="cov0" title="0">
                m.loading = false
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.error = fmt.Sprintf("Failed to load collections: %v", msg.err)
                        m.collections = make([]Collection, 0)
                }</span> else<span class="cov0" title="0"> {
                        m.error = ""
                        m.collections = msg.collections
                        // Reset cursor if it's out of bounds
                        if m.cursor &gt;= len(m.collections) </span><span class="cov0" title="0">{
                                m.cursor = 0
                        }</span>
                        // Send message to notify about collection changes (all collections are selected by default)
                        <span class="cov0" title="0">return m, tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                                return CollectionsUpdatedMsg{
                                        SelectedCollections: m.collectionsService.GetSelectedCollections(),
                                }
                        }</span>)
                }
                <span class="cov0" title="0">m.updateViewportContent()</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the model
func (m Model) View() string <span class="cov0" title="0">{
        if m.width == 0 || m.height == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Header section
        <span class="cov0" title="0">var header strings.Builder

        // Title
        titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("4")).
                PaddingBottom(1)
        header.WriteString(titleStyle.Render("RAG Collections"))
        header.WriteString("\n\n")

        // Connection status
        connectionStyle := lipgloss.NewStyle()
        if m.connected </span><span class="cov0" title="0">{
                connectionStyle = connectionStyle.Foreground(lipgloss.Color("2")) // Green
                header.WriteString(connectionStyle.Render("✓ Connected to ChromaDB"))
        }</span> else<span class="cov0" title="0"> {
                connectionStyle = connectionStyle.Foreground(lipgloss.Color("1")) // Red
                header.WriteString(connectionStyle.Render("✗ Not connected to ChromaDB"))
                if m.error != "" </span><span class="cov0" title="0">{
                        header.WriteString(fmt.Sprintf(" - %s", m.error))
                }</span>
        }
        <span class="cov0" title="0">header.WriteString("\n\n")

        // Instructions
        if m.connected &amp;&amp; !m.loading </span><span class="cov0" title="0">{
                instructionsStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("8"))
                header.WriteString(instructionsStyle.Render("Use ↑/↓ to navigate, Space/Enter to toggle, Ctrl+A to select all, Ctrl+D to deselect all, R to refresh"))
        }</span> else<span class="cov0" title="0"> if !m.connected </span><span class="cov0" title="0">{
                instructionsStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("8"))
                header.WriteString(instructionsStyle.Render("Press T to test connection, C to show config, U to refresh config, X to stop loading"))
        }</span>
        <span class="cov0" title="0">header.WriteString("\n\n")

        // Main content area
        var content string
        if m.loading </span><span class="cov0" title="0">{
                loadingStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("6"))
                content = loadingStyle.Render("Loading...")
        }</span> else<span class="cov0" title="0"> if !m.connected </span><span class="cov0" title="0">{
                content = "ChromaDB connection required to view collections.\nEnsure ChromaDB is running and URL is configured in Settings."
        }</span> else<span class="cov0" title="0"> if len(m.collections) == 0 </span><span class="cov0" title="0">{
                content = "No collections found in ChromaDB."
        }</span> else<span class="cov0" title="0"> {
                content = m.viewport.View()
        }</span>

        // Footer section
        <span class="cov0" title="0">var footer strings.Builder
        if m.connected &amp;&amp; len(m.collections) &gt; 0 </span><span class="cov0" title="0">{
                selectedCount := m.collectionsService.GetSelectedCount()
                totalCount := len(m.collections)

                countStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("4")).
                        Bold(true)
                footer.WriteString(countStyle.Render(fmt.Sprintf("Selected: %d/%d collections", selectedCount, totalCount)))
        }</span>

        // Combine all sections
        <span class="cov0" title="0">var output strings.Builder
        output.WriteString(header.String())
        output.WriteString(content)
        if footer.Len() &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("\n\n")
                output.WriteString(footer.String())
        }</span>

        // Container with border (matching other tabs)
        // Calculate height like main TUI does for content area
        <span class="cov0" title="0">tabBarHeight := 1
        footerHeight := 1
        contentHeight := m.height - tabBarHeight - footerHeight
        if contentHeight &lt; 1 </span><span class="cov0" title="0">{
                contentHeight = 1
        }</span>

        <span class="cov0" title="0">containerStyle := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("#8A7FD8")).
                Padding(1, 2).
                Width(m.width - 2).
                Height(contentHeight) // Match main TUI's content height calculation

        return containerStyle.Render(output.String())</span>
}

// testConnection starts connection testing
func (m Model) testConnection() tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                err := m.collectionsService.TestConnection()
                return connectionTestMsg{
                        connected: m.collectionsService.IsConnected(),
                        err:       err,
                }
        }</span>)
}

// loadCollections starts collections loading
func (m Model) loadCollections(ctx context.Context) tea.Cmd <span class="cov0" title="0">{
        return tea.Cmd(func() tea.Msg </span><span class="cov0" title="0">{
                err := m.collectionsService.LoadCollections(ctx)
                return collectionsLoadedMsg{
                        collections: m.collectionsService.GetCollections(),
                        err:         err,
                }
        }</span>)
}

// updateViewportContent updates the viewport with current collections
func (m *Model) updateViewportContent() <span class="cov0" title="0">{
        if len(m.collections) == 0 </span><span class="cov0" title="0">{
                m.viewport.SetContent("")
                return
        }</span>

        <span class="cov0" title="0">var content strings.Builder

        for i, collection := range m.collections </span><span class="cov0" title="0">{
                var line strings.Builder

                // Selection indicator
                if collection.Selected </span><span class="cov0" title="0">{
                        line.WriteString("● ")
                }</span> else<span class="cov0" title="0"> {
                        line.WriteString("○ ")
                }</span>

                // Collection name
                <span class="cov0" title="0">nameStyle := lipgloss.NewStyle()
                if i == m.cursor </span><span class="cov0" title="0">{
                        nameStyle = nameStyle.Background(lipgloss.Color("4")).
                                Foreground(lipgloss.Color("15")).
                                Bold(true)
                }</span> else<span class="cov0" title="0"> if collection.Selected </span><span class="cov0" title="0">{
                        nameStyle = nameStyle.Foreground(lipgloss.Color("2")).
                                Bold(true)
                }</span>

                <span class="cov0" title="0">line.WriteString(nameStyle.Render(collection.Name))

                // Collection ID (truncated if too long)
                idStyle := lipgloss.NewStyle().
                        Foreground(lipgloss.Color("8"))

                if i == m.cursor </span><span class="cov0" title="0">{
                        idStyle = idStyle.Background(lipgloss.Color("4")).
                                Foreground(lipgloss.Color("7"))
                }</span>

                <span class="cov0" title="0">collectionID := collection.ID
                if len(collectionID) &gt; 20 </span><span class="cov0" title="0">{
                        collectionID = collectionID[:17] + "..."
                }</span>
                <span class="cov0" title="0">line.WriteString(idStyle.Render(fmt.Sprintf(" [%s]", collectionID)))

                // Add metadata count if available (for future expansion)
                if len(collection.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                        metaStyle := lipgloss.NewStyle().
                                Foreground(lipgloss.Color("8"))
                        if i == m.cursor </span><span class="cov0" title="0">{
                                metaStyle = metaStyle.Background(lipgloss.Color("4")).
                                        Foreground(lipgloss.Color("7"))
                        }</span>
                        <span class="cov0" title="0">line.WriteString(metaStyle.Render(fmt.Sprintf(" (%d metadata)", len(collection.Metadata))))</span>
                }

                <span class="cov0" title="0">content.WriteString(line.String())
                if i &lt; len(m.collections)-1 </span><span class="cov0" title="0">{
                        content.WriteString("\n")
                }</span>
        }

        <span class="cov0" title="0">m.viewport.SetContent(content.String())</span>
}

// updateViewportScroll updates viewport scroll position based on cursor
func (m *Model) updateViewportScroll() <span class="cov0" title="0">{
        if len(m.collections) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate which line the cursor is on
        <span class="cov0" title="0">lineHeight := 1
        cursorLine := m.cursor * lineHeight

        // Get viewport boundaries
        top := m.viewport.YOffset
        bottom := top + m.viewport.Height - 1

        // Scroll if cursor is outside viewport
        if cursorLine &lt; top </span><span class="cov0" title="0">{
                m.viewport.YOffset = cursorLine
        }</span> else<span class="cov0" title="0"> if cursorLine &gt; bottom </span><span class="cov0" title="0">{
                m.viewport.YOffset = cursorLine - m.viewport.Height + 1
        }</span>
}

// GetSelectedCollections returns the list of selected collection names
func (m Model) GetSelectedCollections() []string <span class="cov0" title="0">{
        return m.collectionsService.GetSelectedCollections()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package tui

import (
        "context"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/kevensen/gollama-chat/internal/configuration"
        "github.com/kevensen/gollama-chat/internal/tui/tabs/chat"
        configTab "github.com/kevensen/gollama-chat/internal/tui/tabs/configuration"
        "github.com/kevensen/gollama-chat/internal/tui/tabs/configuration/utils/connection"
        ragTab "github.com/kevensen/gollama-chat/internal/tui/tabs/rag"
)

// Tab represents the different tabs in the application
type Tab int

const (
        ChatTab Tab = iota
        ConfigTab
        RAGTab
)

// Model represents the main TUI model
type Model struct {
        config      *configuration.Config
        activeTab   Tab
        tabs        []string
        chatModel   chat.Model
        configModel configTab.Model
        ragModel    ragTab.Model
        width       int
        height      int
}

// NewModel creates a new TUI model
func NewModel(ctx context.Context, config *configuration.Config) Model <span class="cov0" title="0">{
        return Model{
                config:      config,
                activeTab:   ChatTab,
                tabs:        []string{"Chat", "Settings", "RAG Collections"},
                chatModel:   chat.NewModel(ctx, config),
                configModel: configTab.NewModel(config),
                ragModel:    ragTab.NewModel(ctx, config),
        }
}</span>

// Init initializes the TUI model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                m.chatModel.Init(),
                m.configModel.Init(),
                m.ragModel.Init(),
        )
}</span>

// Update handles messages and updates the model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd
        var cmds []tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                // Use 90% of terminal dimensions for better visibility (reduced from 95%)
                m.width = int(float64(msg.Width) * 0.90)
                m.height = int(float64(msg.Height) * 0.90)

                // Update child models with new size
                chatModel, chatCmd := m.chatModel.Update(tea.WindowSizeMsg{
                        Width:  m.width,
                        Height: m.height,
                })
                m.chatModel = chatModel.(chat.Model)
                if chatCmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, chatCmd)
                }</span>

                <span class="cov0" title="0">configModel, configCmd := m.configModel.Update(tea.WindowSizeMsg{
                        Width:  m.width,
                        Height: m.height,
                })
                m.configModel = configModel.(configTab.Model)
                if configCmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, configCmd)
                }</span>

                <span class="cov0" title="0">ragModel, ragCmd := m.ragModel.Update(tea.WindowSizeMsg{
                        Width:  m.width,
                        Height: m.height,
                })
                m.ragModel = ragModel.(ragTab.Model)
                if ragCmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, ragCmd)
                }</span>

        case tea.KeyMsg:<span class="cov0" title="0">
                // ULTRA-FAST PATH: Handle ASCII input with proper encapsulation
                if m.activeTab == ChatTab </span><span class="cov0" title="0">{
                        // Handle space character specifically
                        if msg.String() == " " </span><span class="cov0" title="0">{
                                if m.chatModel.HandleFastInputChar(' ') </span><span class="cov0" title="0">{
                                        return m, nil
                                }</span>
                        }

                        // Use Runes directly for other ASCII characters
                        <span class="cov0" title="0">if msg.Type == tea.KeyRunes &amp;&amp; len(msg.Runes) == 1 </span><span class="cov0" title="0">{
                                char := msg.Runes[0]
                                if m.chatModel.HandleFastInputChar(char) </span><span class="cov0" title="0">{
                                        return m, nil
                                }</span>
                        }
                }

                <span class="cov0" title="0">switch msg.String() </span>{
                case "ctrl+c", "q":<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case "tab":<span class="cov0" title="0">
                        // Switch tabs
                        oldTab := m.activeTab
                        m.activeTab = (m.activeTab + 1) % Tab(len(m.tabs))
                        // Trigger initialization when switching to RAG tab
                        if oldTab != RAGTab &amp;&amp; m.activeTab == RAGTab </span><span class="cov0" title="0">{
                                // Test connection when entering RAG tab
                                ragModel, ragCmd := m.ragModel.Update(tea.WindowSizeMsg{Width: m.width, Height: m.height})
                                m.ragModel = ragModel.(ragTab.Model)
                                initCmd := m.ragModel.Init()
                                if ragCmd != nil &amp;&amp; initCmd != nil </span><span class="cov0" title="0">{
                                        cmd = tea.Batch(ragCmd, initCmd)
                                }</span> else<span class="cov0" title="0"> if ragCmd != nil </span><span class="cov0" title="0">{
                                        cmd = ragCmd
                                }</span> else<span class="cov0" title="0"> if initCmd != nil </span><span class="cov0" title="0">{
                                        cmd = initCmd
                                }</span>
                        }
                        // Sync selected collections when switching to Chat tab
                        <span class="cov0" title="0">if m.activeTab == ChatTab </span><span class="cov0" title="0">{
                                m.syncRAGCollections()
                        }</span>
                case "shift+tab":<span class="cov0" title="0">
                        // Switch tabs in reverse
                        oldTab := m.activeTab
                        m.activeTab = (m.activeTab - 1 + Tab(len(m.tabs))) % Tab(len(m.tabs))
                        // Trigger initialization when switching to RAG tab
                        if oldTab != RAGTab &amp;&amp; m.activeTab == RAGTab </span><span class="cov0" title="0">{
                                // Test connection when entering RAG tab
                                ragModel, ragCmd := m.ragModel.Update(tea.WindowSizeMsg{Width: m.width, Height: m.height})
                                m.ragModel = ragModel.(ragTab.Model)
                                initCmd := m.ragModel.Init()
                                if ragCmd != nil &amp;&amp; initCmd != nil </span><span class="cov0" title="0">{
                                        cmd = tea.Batch(ragCmd, initCmd)
                                }</span> else<span class="cov0" title="0"> if ragCmd != nil </span><span class="cov0" title="0">{
                                        cmd = ragCmd
                                }</span> else<span class="cov0" title="0"> if initCmd != nil </span><span class="cov0" title="0">{
                                        cmd = initCmd
                                }</span>
                        }
                        // Sync selected collections when switching to Chat tab
                        <span class="cov0" title="0">if m.activeTab == ChatTab </span><span class="cov0" title="0">{
                                m.syncRAGCollections()
                        }</span>
                default:<span class="cov0" title="0">
                        // Forward key messages to the active tab
                        switch m.activeTab </span>{
                        case ChatTab:<span class="cov0" title="0">
                                chatModel, chatCmd := m.chatModel.Update(msg)
                                m.chatModel = chatModel.(chat.Model)
                                cmd = chatCmd</span>
                        case ConfigTab:<span class="cov0" title="0">
                                configModel, configCmd := m.configModel.Update(msg)
                                m.configModel = configModel.(configTab.Model)
                                cmd = configCmd</span>
                        case RAGTab:<span class="cov0" title="0">
                                ragModel, ragCmd := m.ragModel.Update(msg)
                                m.ragModel = ragModel.(ragTab.Model)
                                cmd = ragCmd</span>
                        }
                }

        default:<span class="cov0" title="0">
                // Handle configuration updates
                if configMsg, isConfigUpdate := msg.(ragTab.ConfigUpdatedMsg); isConfigUpdate </span><span class="cov0" title="0">{
                        // Update the main config
                        m.config = configMsg.Config

                        // Update the RAG model with the new configuration
                        ragModel, ragCmd := m.ragModel.Update(configMsg)
                        m.ragModel = ragModel.(ragTab.Model)
                        cmd = ragCmd
                }</span> else<span class="cov0" title="0"> if collectionsMsg, isCollectionsUpdate := msg.(ragTab.CollectionsUpdatedMsg); isCollectionsUpdate </span><span class="cov0" title="0">{
                        // Handle collection selection changes
                        selectedCollectionsMap := make(map[string]bool)
                        for _, collectionName := range collectionsMsg.SelectedCollections </span><span class="cov0" title="0">{
                                selectedCollectionsMap[collectionName] = true
                        }</span>

                        // Update the chat model's RAG service
                        <span class="cov0" title="0">ragService := m.chatModel.GetRAGService()
                        if ragService != nil </span><span class="cov0" title="0">{
                                ragService.UpdateSelectedCollections(selectedCollectionsMap)
                        }</span>

                        // Still forward the message to the RAG tab
                        <span class="cov0" title="0">ragModel, ragCmd := m.ragModel.Update(msg)
                        m.ragModel = ragModel.(ragTab.Model)
                        cmd = ragCmd</span>
                } else<span class="cov0" title="0"> if _, isConnectionMsg := msg.(connection.CheckMsg); isConnectionMsg </span><span class="cov0" title="0">{
                        // Check if this is a ConnectionCheckMsg and route it to config tab
                        configModel, configCmd := m.configModel.Update(msg)
                        m.configModel = configModel.(configTab.Model)
                        cmd = configCmd
                }</span> else<span class="cov0" title="0"> {
                        // Forward other messages to the active tab
                        switch m.activeTab </span>{
                        case ChatTab:<span class="cov0" title="0">
                                chatModel, chatCmd := m.chatModel.Update(msg)
                                m.chatModel = chatModel.(chat.Model)
                                cmd = chatCmd</span>
                        case ConfigTab:<span class="cov0" title="0">
                                configModel, configCmd := m.configModel.Update(msg)
                                m.configModel = configModel.(configTab.Model)
                                cmd = configCmd</span>
                        case RAGTab:<span class="cov0" title="0">
                                ragModel, ragCmd := m.ragModel.Update(msg)
                                m.ragModel = ragModel.(ragTab.Model)
                                cmd = ragCmd</span>
                        }
                }
        }

        <span class="cov0" title="0">if cmd != nil </span><span class="cov0" title="0">{
                cmds = append(cmds, cmd)
        }</span>

        <span class="cov0" title="0">return m, tea.Batch(cmds...)</span>
}

// View renders the TUI
func (m Model) View() string <span class="cov0" title="0">{
        // For very small terminals, prioritize tabs and minimal content
        if m.height &lt; 3 </span><span class="cov0" title="0">{
                // In extreme cases, just show tabs
                if m.height == 1 </span><span class="cov0" title="0">{
                        return m.renderTabBar()
                }</span>
                // With 2 lines, show tabs and minimal content
                <span class="cov0" title="0">if m.height == 2 </span><span class="cov0" title="0">{
                        tabBar := m.renderTabBar()
                        return lipgloss.JoinVertical(lipgloss.Left, tabBar, "...")
                }</span>
        }

        // Tab bar
        <span class="cov0" title="0">tabBar := m.renderTabBar()

        // Content area
        var content string
        switch m.activeTab </span>{
        case ChatTab:<span class="cov0" title="0">
                content = m.chatModel.View()</span>
        case ConfigTab:<span class="cov0" title="0">
                content = m.configModel.View()</span>
        case RAGTab:<span class="cov0" title="0">
                content = m.ragModel.View()</span>
        }

        // Footer with help
        <span class="cov0" title="0">footer := m.renderFooter()

        // Calculate available height for content with minimum constraints
        tabBarHeight := 1 // Always reserve 1 line for tabs
        footerHeight := 1 // Always reserve 1 line for footer

        // Calculate content height, ensuring it's never negative
        contentHeight := m.height - tabBarHeight - footerHeight
        if contentHeight &lt; 1 </span><span class="cov0" title="0">{
                contentHeight = 1 // Ensure at least 1 line for content
        }</span>

        // For chat tab, don't apply height constraint as it manages its own layout
        // For config and RAG tabs, let them handle their own full height
        <span class="cov0" title="0">var styledContent string
        if m.activeTab == ChatTab </span><span class="cov0" title="0">{
                // Chat tab uses its own layout management
                contentStyle := lipgloss.NewStyle().
                        Height(contentHeight).
                        Width(m.width)
                styledContent = contentStyle.Render(content)
        }</span> else<span class="cov0" title="0"> {
                // Config and RAG tabs manage their own height with containers
                styledContent = content
        }</span>

        // Return the main content without complex centering
        <span class="cov0" title="0">return lipgloss.JoinVertical(
                lipgloss.Left,
                tabBar,
                styledContent,
                footer,
        )</span>
}

// renderTabBar renders the tab bar
func (m Model) renderTabBar() string <span class="cov0" title="0">{
        var tabs []string

        // Use minimal styles to ensure tabs fit in constrained space
        activeTabStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("15")).     // Bright white
                Background(lipgloss.Color("#8A7FD8")) // Purple-blue to match chat border

        inactiveTabStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("7")). // Light gray
                Background(lipgloss.Color("0"))  // Black

        // Create compact tab names for minimal space scenarios
        tabNames := []string{"Chat", "Config", "RAG"}
        if m.width &lt; 30 </span><span class="cov0" title="0">{
                tabNames = []string{"C", "S", "R"} // Single letter tabs for very narrow terminals
        }</span>

        <span class="cov0" title="0">for i, tab := range tabNames </span><span class="cov0" title="0">{
                if i &gt;= len(m.tabs) </span><span class="cov0" title="0">{
                        break</span> // Safety check
                }

                <span class="cov0" title="0">tabText := " " + tab + " " // Add minimal spacing
                if Tab(i) == m.activeTab </span><span class="cov0" title="0">{
                        tabs = append(tabs, activeTabStyle.Render(tabText))
                }</span> else<span class="cov0" title="0"> {
                        tabs = append(tabs, inactiveTabStyle.Render(tabText))
                }</span>
        }

        // Always ensure we have content to render
        <span class="cov0" title="0">tabContent := lipgloss.JoinHorizontal(lipgloss.Top, tabs...)
        if tabContent == "" </span><span class="cov0" title="0">{
                tabContent = " Chat Settings RAG " // Fallback content
        }</span>

        // Create a simple style that guarantees visibility
        <span class="cov0" title="0">tabBarStyle := lipgloss.NewStyle().
                Background(lipgloss.Color("0")). // Black background
                Width(m.width)

        return tabBarStyle.Render(tabContent)</span>
}

// renderFooter renders the footer with help text
func (m Model) renderFooter() string <span class="cov0" title="0">{
        footerStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("240")).
                Background(lipgloss.Color("235")).
                Width(m.width)

        // Simplified help text for small terminals
        helpText := "Tab: Switch • Ctrl+C: Quit"

        // Add more detailed help only if we have enough width
        if m.width &gt; 50 </span><span class="cov0" title="0">{
                helpText = "Tab/Shift+Tab: Switch tabs • Ctrl+C/q: Quit"

                // Add tab-specific help only for wider terminals
                if m.width &gt; 80 </span><span class="cov0" title="0">{
                        switch m.activeTab </span>{
                        case ChatTab:<span class="cov0" title="0">
                                helpText += " • Enter: Send • ↑/↓: Scroll • Ctrl+S: System Prompt"</span>
                        case ConfigTab:<span class="cov0" title="0">
                                helpText += " • Enter: Edit • Esc: Cancel"</span>
                        case RAGTab:<span class="cov0" title="0">
                                helpText += " • Space: Toggle • ↑/↓: Navigate • R: Refresh"</span>
                        }
                }
        }

        <span class="cov0" title="0">return footerStyle.Render(helpText)</span>
}

// syncRAGCollections synchronizes the selected collections from RAG tab to the chat model's RAG service
func (m *Model) syncRAGCollections() <span class="cov0" title="0">{
        // Get the selected collections from the RAG tab
        selectedCollectionNames := m.ragModel.GetSelectedCollections()

        // Convert to the map format expected by UpdateSelectedCollections
        selectedCollectionsMap := make(map[string]bool)
        for _, collectionName := range selectedCollectionNames </span><span class="cov0" title="0">{
                selectedCollectionsMap[collectionName] = true
        }</span>

        // Update the chat model's RAG service with the selected collections
        <span class="cov0" title="0">ragService := m.chatModel.GetRAGService()
        if ragService != nil </span><span class="cov0" title="0">{
                ragService.UpdateSelectedCollections(selectedCollectionsMap)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package util

import (
        tea "github.com/charmbracelet/bubbletea"
)

// IsVisibleASCII checks if the given tea.KeyMsg represents a visible ASCII character
// including the space bar (ASCII 32-126)
func IsVisibleASCII(keyMsg tea.KeyMsg) bool <span class="cov0" title="0">{
        // Get the key string representation
        key := keyMsg.String()

        // Handle space bar specifically
        if key == " " </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if it's a single visible ASCII character (printable characters 33-126)
        // We exclude space (32) here since we handle it above
        <span class="cov0" title="0">if len(key) == 1 </span><span class="cov0" title="0">{
                char := key[0]
                return char &gt;= 33 &amp;&amp; char &lt;= 126
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
